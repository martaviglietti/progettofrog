#include <stdio.h>
#include <time.h>
#include <stdlib.h>
#include <unistd.h>
#include <ncurses.h>
#include <sys/wait.h>
#include <sys/time.h>
#include <locale.h>
#include "menu.h"
#include <string.h>
#include <fcntl.h>
#define MAX_CROCODILES 24
#define LARGHEZZA_GIOCO 81
#define ALTEZZA_GIOCO 49
#define POS_SPAWN_COC_SINISTRA -4
#define POS_SPAWN_COC_DESTRA 84
#define ALTEZZARANA 2
#define LARGHEZZARANA 3
#define ALTEZZACOCCODRILLO 2
#define LARGHEZZACOCCODRILLO 9
#define DELAY 100000
#define TANE 6
#define FIUME 25
#define PRATO 5
#define SPONDA_SUPERIORE 5
#define N_PID 100
//definizione id da usare;
#define IDTIME 45
#define IDCOC 0
#define IDRANA 50
#define IDGRANATE 60
#define IDPROIETTILE 70
#define IDAGGIUNTAPID 30
#define IDMORTE -10
#define IDRICHIESTA 90


// Opzioni del menu
static const char *OPZIONI[] = {
    "Inizia gioco", "Crediti", "Esci"
};

//sprite rana
const char *frog_sprite[2] = {
    "* *",
    "   "
};

const char *coc_sprite[2][2]={{"XXXXXXX","XXXXXX0X0"},{"XXXXXXX","0X0XXXXXX"}};
            


typedef struct{
    int id;
    int y;
    int dir;
    int speed;
}Flusso;




typedef struct{
    int vite;
    int score;
    int tempo;
    int tane[5];
    int game; //serve per la condizione di uscita dal game;
}Game_struct;

typedef struct{
    int vite;
    int tempo;
    int velocità_proiettili;
    int velocità_coccodrilli;
 
}Stat_game;

typedef struct{
    int id;
    int y;
    int x;
    int dir;
    int alive;
    int wait;
}Coccodrillo;

typedef struct{
    int id;
    int y;
    int x;
    int alive;
}Proiettile;

typedef struct{
    int id;
    int y;
    int x;
    int alive;
}Granata;



typedef struct{
    int id;
    int x;
    int y;
}Rana;

typedef struct{
	int id;
	int x;
	int y;
	int info;
}Temp;


int gameWin(WINDOW *game, int score);
int gameOver(WINDOW *game, int score);
int scegliDifficolta(WINDOW *game);
void windowGeneration(WINDOW *game, int maxX, int maxY, Game_struct* game_struct);
Game_struct startGame(WINDOW *game,Stat_game stat_game);
void Gestione_grafica(WINDOW* game,int pipe1[], int pipe2[], int array_pid[],int vel_proiettili, Game_struct* game_struct);
int CollisioneRanaProiettile(Rana* rana,Proiettile proiettile[], Game_struct* game_struct, int fine_manche);
int RanaSuTana(Rana*rana, Game_struct* game_struct);
int RanaSuCoccodrillo(Rana *rana, Coccodrillo *coccodrilli);
void creazione_processi(Flusso *flussi, int array_pid[N_PID], int pipe1[],WINDOW* game);
void funzione_gestione_coccodrilli(Flusso *flussi,int pipe1[]);
void funzione_coccodrillo(Temp coccodrillo,Flusso flussi[8],int id_flusso_scelto, int pipe1[]);
void funz_proiettile(int id,Coccodrillo coccodrillo,int vel_proiettile, int pipe1[]);
void tempo(int pipe1[]);
void kill_processi(pid_t* pid);
void def_vel_flussi(Flusso *flussi, int velocità_coccodrillo);
void def_dir_flussi(Flusso *flussi);
int menu(WINDOW *game, const char *title, const char *options[], int num_options);
void credits(WINDOW *game);
int rand_funz(int min, int max);
void frog(WINDOW* game,int pipe1[2]);
void sparaGranata(int startX, int startY,int vel_proiettile ,int pid_array[],int pipe1[], int pipe2[]);
void sparaProiettile(int id, int identificatore_coc,  Coccodrillo* coccodrilli,int vel_proiettile,int pid_array[], int pipe1[]);
void granata(int startX, int startY,int vel_proiettile,int pipe1[], int pipe2[]);
void creazione_colori();
void draw_proiettile(WINDOW* game, Proiettile proiettile[]);
void draw_granate(WINDOW* game, Granata granate[2]);
void draw_frog(WINDOW *game, Rana* rana);
void drawCoccodrilli(WINDOW *game, Coccodrillo *coccodrilli);
void sblocca_fd(int fd);
void killProcess(pid_t pid);
int RanaInFinestra(Rana* rana, Temp*temp);
void blocca_fd(int fd);
void svuota_pipe(int pipe_fd);
void print_tempo(WINDOW* game,Game_struct* game_struct, int tempo);    
void punteggio_tempo(Game_struct* game_struct);         
void collisione_GranataBordi(int pipe, Granata* granate);
void collisione_ProiettileBordi(int array_pid[], Proiettile proiettile[]);
void collisione_GranataProiettile(int pipe2, Granata* granate, Proiettile proiettile[], int array_pid[], Game_struct* game_struct);
void killa_granata(Granata* granate, int array_pid[]);
void riattivare_coccodrilli(Coccodrillo* coccodrilli, int distanze_coc[], int array_pid[]);
void attesa_coccodrilli(int id, Coccodrillo* coccodrilli, int distanze_coc[], int array_pid[]);
void controllo_stato_coccodrillo(int id,Coccodrillo* coccodrilli);
int spostamento_ranaCoc(int id, int coc_scelto, Coccodrillo* coccodrilli, Rana* rana, Game_struct* game_struct , int fine_manche);
void impostazioni_gioco(Stat_game* stat_game, int difficoltà );


int main(){
    printf("\e[8;%d;%dt", 49, 81);  //ridimensioniamo il terminale
    fflush(stdout);
    setlocale(LC_ALL, "");     // Abilita UTF-8	
    sleep(1);	

    //Inizializziamo ncurses
    initscr();
    noecho();
    cbreak();
    curs_set(0);
    resizeterm(49, 81);  //avvisiamo ncurses del cambio di dimensioni del terminale
    creazione_colori();    
    srand(time(NULL));
    
	
    int height = LINES;
    int width = COLS;
    
    int scelta;	     //variabile contenente la scelta dal menù principale
    int difficoltà;  //variabile contenente la difficoltà scelta dal menù delle difficoltà
    int ricomincia=1;
    
    Stat_game stat_game={0,0,0,0};
    Game_struct risultato;  //conterrà i risultati del game 
    WINDOW *game = newwin(height, width, 0, 0);  //finestra dell'area gioco  
    

    while (true){
    	if (ricomincia) {  //se 'ricomincia' è 0 non torniamo al menu;
            scelta= menu(game,"Menu Principale", OPZIONI, 3);  //se 'ricomincia' è 0 non torniamo al menu;
        }	
	
        if (scelta == 0) { 
         
   	    if (ricomincia) {  //se 'ricomincia' è 0 manteniamo la stessa difficoltà
                difficoltà=scegliDifficolta(game);
            }
        
            impostazioni_gioco(&stat_game, difficoltà);
            
        
        
        
            risultato=startGame(game, stat_game);
            
            if (risultato.game==1) {  //Vittoria
                scelta=gameWin(game,risultato.score); 
            	
            	if (scelta) {	
            	    ricomincia=1;  //torna al menù principale
            	} else {
            	    ricomincia=0;  //ricomincia il game con stessa difficoltà
            	}	
            } else {  //Sconfitta
            	scelta=gameOver(game,risultato.score);
            	if (scelta) {					
            	    ricomincia=1;  //torna al menù principale
            	} else {
            	    ricomincia=0;  //ricomincia il game con stessa difficoltà
            	} 	
            }
        
        } else if (scelta==1) {  //crediti
            credits(game);
        	
        } else {  //Uscita
            wclear(game);
            mvwprintw(game, height / 2, width / 2 - 5, "Uscita...");
            wrefresh(game);
            sleep(1);
            break; // Esci dal programma
        }
    }

    delwin(game);
    endwin();
    return 0;
}

void impostazioni_gioco(Stat_game* stat_game, int difficoltà ){
    switch (difficoltà) {
                case 0:  //Facile
                    stat_game->vite=10;			   //numero vite
                    stat_game->tempo=100;		   //tempo di gioco
                    stat_game->velocità_proiettili=30000;   //velocità proiettili
                    stat_game->velocità_coccodrilli=100000;  //velocità coccodrilli
                    break;
                case 1:  //Medio
                    stat_game->vite=10;
                    stat_game->tempo=30;
                    stat_game->velocità_proiettili=30000;
                    stat_game->velocità_coccodrilli=50000;
                    break;
                case 2:  //Difficile
                    stat_game->vite=10;
                    stat_game->tempo=30;
                    stat_game->velocità_proiettili=3000;
                    stat_game->velocità_coccodrilli=50000;
                    break;      
            }
}

int gameWin(WINDOW *game, int score){  //schermata in caso di vittoria
    wclear(game);
    box(game, ACS_VLINE, ACS_HLINE);
    mvwprintw(game, 10, 10, "HAI VINTO! Punteggio: %d. Vuoi giocare ancora? (s/n)", score);
    wrefresh(game);
    char decision = wgetch(game);
    while (decision!= 's' && decision!='n') {
        decision = wgetch(game);
    }
    if (decision == 's') {  //se rispondiamo di si ripetiamo il game (con stessa difficoltà) da capo
        return 0;
    } else {  //altrimenti torniamo al menù
        return 1;
    }
}


int gameOver(WINDOW *game, int score){  //schermata in caso di perdita
    wclear(game);
    box(game, ACS_VLINE, ACS_HLINE);
    mvwprintw(game, 10, 10, "GAME OVER! Punteggio: %d. Vuoi giocare ancora? (s/n)", score);
    wrefresh(game);
    char decision = wgetch(game);
    while (decision!= 's' && decision!='n') {
    	 decision = wgetch(game);
    }
    if (decision == 's') {  //se rispondiamo di si ripetiamo il game (con stessa difficoltà) da capo
        return 0;
    } else {  //altrimenti torniamo al menù
        return 1;
    }
}



int scegliDifficolta(WINDOW *game) {  //schermata per scelta della difficoltà
    const char *difficolta[] = {"Facile", "Media", "Difficile"};
    return menu(game, "Scegli la Difficoltà", difficolta, 3);
}


void windowGeneration(WINDOW *game, int maxX, int maxY, Game_struct* game_struct){
    
    box(game, ACS_VLINE, ACS_HLINE);
    int offsetSumV=0;  
    int offsetSumH=1;  
    
    //Definiamo la mappa di gioco
    char tane[TANE][LARGHEZZA_GIOCO-2]={
        "     ..o..            o                   .          o                o        ",
    	"                 o               O                           .                 ",
    	"     +-------+      +-------+      +-------+      +-------+      +-------+  O  ",		          
    	"     |*******|      |*******|      |*******|      |*******|      |*******|     ",			
    	"  .  |*******|      |*******|   o  |*******|      |*******|      |*******|     ",
    	"     |*******|      |*******|      |*******|      |*******|      |*******|     "
    };	
    							 
    char fiume[FIUME][LARGHEZZA_GIOCO-2]={
 	"                                                                               ",
    	"              ~                                                                ",
    	"                         ~                ~          ~                 ~       ",
    	"        ~                     ~                                                ",
    	"                                                        ~          ~           ",
    	"                                    ~                                          ",
    	"                                               ~                               ",
    	"                ~            ~                                                 ",
    	"                                                        ~                      ",
    	"                                             ~                                 ",	
    	"         ~                      ~                                              ",
    	"                                                                   ~           ",
    	"                                                                               ",
    	"                     ~                    ~          ~                         ",
    	"                                                                               ",
    	"                                                          ~                    ",
    	"             ~            ~          ~            ~                     ~      ",
    	"                                                                               ",
    	"                                                                ~              ",
    	"                                ~           ~                                  ",
    	"         ~                                                                     ",
    	"                                                                               ",
    	"              ~            ~                           ~                       ",
    	"                                      ~                       ~     ~          ",
    	"                                                                               "
    };     
    
    char prato[PRATO][LARGHEZZA_GIOCO-2]={   
    
    	"      .                                                                        ",
    	"                   /          |                      /          .     \\        ",
    	"         \\                                       .                             ",
    	"   .             .                 .                       \\          .        ",
    	"                          /                     /                              "
    };
    
    offsetSumV += 4; 
    
    //Sezione Tane
    
    //Printiamo zona intorno alle tane
    wattron(game,COLOR_PAIR(3));
    for (int i=0; i<TANE;i++) {
    	for (int j=0; j<maxX-2;j++) {				
    	    if (tane[i][j]==' ' || tane[i][j]=='o' || tane[i][j]=='O' || tane[i][j]=='.') {  		
    	        mvwaddch(game,i+offsetSumV,j+offsetSumH,tane[i][j]);
            } 		
    	      
        }
    }
    wattroff(game,COLOR_PAIR(3));
    
    //Printiamo le tane
    
    for(int i=0; i<5;i++){
	if(game_struct->tane[i]==0){
            wattron(game,COLOR_PAIR(4));
	    for (int v=2; v<TANE;v++) {
	    	for (int h=5+(8+7)*i; h<5+(8+7)*i+9 ;h++) {							
	    	    if (tane[v][h]=='|' || tane[v][h]=='+' || tane[v][h]=='-') {				
	    	     	 mvwaddch(game,v+offsetSumV,h+offsetSumH,tane[v][h]);
	            }
	       	}
 	    }
	    wattroff(game,COLOR_PAIR(4));
	    wattron(game,COLOR_PAIR(5));
	    for (int v=2; v<TANE;v++) {
	    	for (int h=5+(8+7)*i; h<5+(8+7)*i+9 ;h++) {
	    	    if (tane[v][h]=='*') {									
	    	        mvwaddch(game,v+offsetSumV,h+offsetSumH,tane[v][h]);
	   	    }
	   	}
	    }
	    wattroff(game,COLOR_PAIR(5));
    
	} else {
	    
	    wattron(game,COLOR_PAIR(3));
	    for (int v=2; v<TANE;v++) {
		for (int h=5+(8+7)*i; h<5+(8+7)*i+9 ;h++) {								
	     	    mvwaddch(game,v+offsetSumV,h+offsetSumH,' ');
		}
	    }
	    wattroff(game,COLOR_PAIR(3));    
	}
    }
    
    offsetSumV += TANE;  
    
    //Sezione sponda superiore
    
    wattron(game, COLOR_PAIR(6)); 
    for (int i = 0; i < SPONDA_SUPERIORE; i++) {
        mvwhline(game, offsetSumV + i, offsetSumH, ' ', maxX - 2);
    }
    wattroff(game, COLOR_PAIR(6));
   
    offsetSumV += SPONDA_SUPERIORE;  


    //Sezione Fiume
    
    wattron(game,COLOR_PAIR(2));
    for (int i=0; i<FIUME;i++) {
        for (int j=0; j<maxX-2;j++) {										
    	    mvwaddch(game,i+offsetSumV,j+offsetSumH,fiume[i][j]);
        }
    }
    wattroff(game,COLOR_PAIR(2));
    
    offsetSumV += FIUME;  
    
    
    //Sezione Prato
    
    wattron(game,COLOR_PAIR(8));
    for (int i=0; i<PRATO;i++) {
    	for (int j=0; j<maxX-2;j++) {											
    	    mvwaddch(game,i+offsetSumV,j+offsetSumH,prato[i][j]);
        }
    }
    wattroff(game,COLOR_PAIR(8));
    
    //print zona esterna 
    wattron(game,COLOR_PAIR(14));
    mvwhline(game, 1,1, ' ', maxX - 2);
    mvwhline(game, 3,1, ' ', maxX - 2);
    mvwhline(game, 45,1, ' ', maxX - 2);  
    mvwhline(game, 47,1, ' ', maxX - 2);  
    mvwhline(game, 2,15, ' ', 35);
    mvwhline(game, 46,77, ' ', 3);
    mvwhline(game, 46,12, ' ', 3);
    mvwhline(game, 2,76, ' ', 4);
   
    mvwaddch(game,46,78,' ');
    mvwaddch(game,46,77,' ');
    mvwaddch(game,46,78,' ');
    mvwaddch(game,46,1,' ');
    mvwaddch(game,2,1,' ');
    
    wattroff(game,COLOR_PAIR(14));
    
    //print score
    wattron(game, COLOR_PAIR(15));
    mvwprintw(game, 2, 2, "Punteggio: %d ",game_struct->score);
    wattroff(game, COLOR_PAIR(15));
    
    //print vite
    wattron(game, COLOR_PAIR(15));
    mvwprintw(game, 2, 50, "Vite:");
    mvwhline(game, 2,55, ' ', 21);
    for(int i=0; i<game_struct->vite;i++){
    	mvwprintw(game, 2, 55+i*2, "❤️  ");
       
    } 
	    	
    wattroff(game, COLOR_PAIR(15));
    
    
    //print tempo
    wattron(game, COLOR_PAIR(15));
    mvwhline(game, 46,2, ' ', 10);
    mvwprintw(game, 46, 2, "Tempo: %d ",game_struct->tempo);
    wattroff(game, COLOR_PAIR(15));

    
    
    
    
    
};


Game_struct startGame(WINDOW *game,Stat_game stat_game){			
    
    //Creazione pipe;
    int pipe1[2];  //per comunicare tra consumatore e produttori;
    int pipe2[2];  //per comunicare alla granata se è morta;
    pipe(pipe1);        
    pipe(pipe2);
    sblocca_fd(pipe1[0]);  //sblocchiamo la pipe1	
    sblocca_fd(pipe2[0]);  //sblocchiamo la pipe2
   
    //Inizializziamo variabili di gestione della partita
    int tane_occupate=0;
    Game_struct game_struct;
    game_struct.score=0; 		//contiene lo score di tutto il game
    game_struct.vite=stat_game.vite;    //contiene numero di vite rimaste
    game_struct.tempo=stat_game.tempo;  //contiene tempo rimasto nella manche
   
    for (int i=0;i<TANE-1;i++) {
        game_struct.tane[i]=0;
    }
    
    Flusso flussi[8];
    def_vel_flussi(flussi,stat_game.velocità_coccodrilli); //definisco velocità di ogni flusso                
    int array_pid[N_PID];  //array contenente i pid dei processi creati  
    
    int a;
    
    while (true) {
        
        def_dir_flussi(flussi);  //definisce direzione di ogni flusso					
    	creazione_processi(flussi,array_pid, pipe1,game);  //crea tutti i processi
	Gestione_grafica(game,pipe1,pipe2,array_pid,stat_game.velocità_proiettili,&game_struct);  //funzione di gestione grafica
    	game_struct.tempo=stat_game.tempo; 	
	svuota_pipe(pipe1[0]);  //svuotiamo la pipe per eliminare eventuali elementi rimasti all'interno
	
	if(read(pipe1[0],&a,sizeof(int))!= -1){
	    perror("roba nella pipe");
	}
	


   	kill_processi(array_pid);		
   	
        //Controlli di fine manche
        if (game_struct.vite==0) { 
 	    game_struct.game=0;
 	    game_struct.score-=50;
 	    return game_struct;  //uscita per vite finite
	}
	
   	for (int i=0;i<5;i++) {
 	    if(game_struct.tane[i]==1){
  	        tane_occupate++;
  	    }
 	}
 	
 	if (tane_occupate==5) {		
 	    game_struct.game=1;
 	    game_struct.score+=100;
	    return game_struct;  //uscita per tane chiuse
 	}
	tane_occupate=0;
   
	wclear(game);
	wrefresh(game);     
	}
}


void Gestione_grafica(WINDOW* game,int pipe1[], int pipe2[], int array_pid[],int vel_proiettile, Game_struct* game_struct){			
	
    //Variabili per gestione proiettile
    struct timeval start, end; 
    gettimeofday(&end,NULL);		
    gettimeofday(&start,NULL);
    long time_proiettile; 
    int random=rand_funz(2,4);

    int result; //contiene il risultato delle funzioni di collisione;	 
    Temp temp={-1,0,0,0};
    int b=0;

    //Inizializzazione degli elementi di gioco
    Coccodrillo coccodrilli[MAX_CROCODILES];
    for (int i=0; i<MAX_CROCODILES;i++) {
        coccodrilli[i].id=i;      //id coccodrillo
	coccodrilli[i].x=-1;	  //posizione x coccodrillo
	coccodrilli[i].y=-1;      //posizione y coccodrillo
	coccodrilli[i].dir=0;     //direzione coccodrillo
	coccodrilli[i].alive=0;   //stato del coccoddrillo
	coccodrilli[i].wait=-1;}  //variabile per stato di attesa

    Granata granate[2];
    for (int i=0; i<2;i++) {
	granate[i].id=i;
	granate[i].x=-1;
	granate[i].y=-1;
	granate[i].alive=0;}
		
    Rana rana;	
    rana.id=IDRANA;
    rana.x=40; 
    rana.y=43;

    Proiettile proiettili[15];
    for(int i=0;i<15;i++){
        proiettili[i].id=IDPROIETTILE+i;
        proiettili[i].x=-1;
        proiettili[i].y=-1;
        proiettili[i].alive=0;
    }
    
    
   
    int tempo=game_struct->tempo;
    int coc_scelto;  //variabile utilizzata per indicare su quale coccodrillo posa la rana
    
   
    int distanze_coc[8];
    
    for (int i=0; i<8;i++) {
	distanze_coc[i]=rand_funz(13,16);  //impostiamo le distanze iniziali tra coccodrilli per ogni flusso del fiume
    }
   
    
    int fine_manche=1;  //variabile utilizzata per terminare la manche
    int coccodrilloCheSpara;
    
    while (fine_manche) {
    	
	fine_manche=1;  //se durante il ciclo viene impostata a 0 allora si esce dal game
	temp.id=-1;
	
		//funzioni di gestione grafica del gioco
	    werase(game);
	    windowGeneration(game,COLS,LINES,game_struct);
	    drawCoccodrilli(game,coccodrilli);
	    draw_granate(game,granate);
	    draw_proiettile(game,proiettili);
	    draw_frog(game,&rana);
	    print_tempo(game,game_struct,tempo); //barra del tempo

	    
	    wrefresh(game);
	
	
        read(pipe1[0],&temp,sizeof(Temp));  //leggiamo il messaggio nella pipe
	
	//se l'ID è della rana						
	if (temp.id==IDRANA) {
	    if (RanaInFinestra(&rana,&temp)) {  //controllo per evitare che la rana fuoriesca dalla finestra di gioco
	        rana.x+=temp.x;
	        rana.y+=temp.y;	
	
		if (rana.y<10) {  //controllo se la rana si trova nella zona delle tane			
		    if (RanaSuTana(&rana,game_struct)) {  //controllo se la rana si trova su una delle tane        
		        game_struct->score+=15;
			game_struct->score+=(int)(15*(float)game_struct->tempo/100);
			fine_manche=0;						
		    } else {  //altrimenti la rana si trova nella zona circostante alle tane
		        game_struct->vite--;
			game_struct->score-=10; 
		        fine_manche=0;
		    }
		}
	    }  
        }
	
	//se l'id è del processo tempo
	if (temp.id==IDTIME) {	
	    game_struct->tempo-=1;
	    if (game_struct->tempo==0) {  //controllo per verificare se il tempo è terminato
	        game_struct->vite--;
		game_struct->score-=20;
		fine_manche=0;
	    }
	}

	
	//se l'ID è di un coccodrillo
	if (temp.id<MAX_CROCODILES && temp.id>=0) {
	    if (temp.y!=IDAGGIUNTAPID) {  //controlliamo se il messaggio proviene dal generatore dei coccodrilli
		coc_scelto=RanaSuCoccodrillo(&rana,coccodrilli);  //controllo di verifica che la rana sia già su un coccodrillo (qualsiasi) prima dello spostamento
		coccodrilli[temp.id].x=temp.x;
		coccodrilli[temp.id].y=temp.y;
	        coccodrilli[temp.id].dir=temp.info;  
		
		//controlli per lo spostamento della rana
		fine_manche=spostamento_ranaCoc(temp.id, coc_scelto,coccodrilli, &rana,game_struct, fine_manche);	
		
		//controllo sullo stato del coccodrillo
		controllo_stato_coccodrillo(temp.id,coccodrilli);
			
			
			
			
		//gestione dello stato di attesa 
		attesa_coccodrilli(temp.id, coccodrilli,distanze_coc,array_pid);
		riattivare_coccodrilli(coccodrilli, distanze_coc, array_pid);
		
		
				
			
		
	    } else {  //altrimenti aggiungiamo il pid del coccodrillo all'array dei pid
	        array_pid[temp.id]=temp.info; //salva l id del coccodrillo creato;	
	    }
	}
	
	


	//se l'id è delle granate
	if (temp.id>=IDGRANATE && temp.id<=IDGRANATE+2) {
	    if (temp.id==IDGRANATE+2) {
	        if (granate[0].alive==0 && granate[1].alive==0) {  //devono essere entrambe morte;		
	            sparaGranata(rana.x,rana.y,vel_proiettile,array_pid,pipe1,pipe2);
	            granate[0].alive=1;
                    granate[1].alive=1;
          
                    
	            
	        }
	    } else {
	        granate[temp.id-IDGRANATE].x=temp.x;	
		granate[temp.id-IDGRANATE].y=temp.y;
		
			   
	    }	  
	}
	
	
	
	
	//se l'id è del proiettile
	if (temp.id>=IDPROIETTILE && temp.id<IDPROIETTILE+15) {	
	    proiettili[temp.id].x=temp.x;
	    proiettili[temp.id].y=temp.y;
	}
	
	
	//controllo collisione proiettile-bordi
	collisione_ProiettileBordi(array_pid, proiettili);
	
	
	//controllo collisione granate/bordi
	collisione_GranataBordi(pipe2[1],granate);
	

	
	//controllo collisione rana-proiettile
	fine_manche=CollisioneRanaProiettile(&rana, proiettili,game_struct, fine_manche);   
	
	
	//controllo collisione granata-proiettile
	collisione_GranataProiettile(pipe2[1],granate, proiettili, array_pid,game_struct);
	
	
	//controllo per killare il processo granate una volta morte
	killa_granata(granate, array_pid);
	
	
	
	
	
    
	
    
    }
}


int spostamento_ranaCoc(int id, int coc_scelto, Coccodrillo* coccodrilli, Rana* rana, Game_struct* game_struct, int fine_manche ) {

    if (coc_scelto==coccodrilli[id].id) {  //controlliamo che il coccodrillo attuale sia anche quello su cui la rana era posata prima dello spostamento
		    if ((rana->x<=2 && coccodrilli[id].dir==-1) || (rana->x>=LARGHEZZA_GIOCO-3 && coccodrilli[id].dir==1)) {  //controllo se la rana si trova agli estremi della mappa			
			if (RanaSuCoccodrillo(rana,coccodrilli)!=coc_scelto) {	//se la rana non viene considerata più sopra l'attuale coccodrillo allora è caduta in acqua sul bordo della mappa 
			    game_struct->vite--;
			    game_struct->score-=10;
			    
			    return 0;
			}	
		    } else {	 //altrimenti la rana si muove con il coccodrillo (ovvero non si trovava agli estremi della mappa)					
		        rana->x+=coccodrilli[id].dir;
		    }               			
    }
    return fine_manche;

}

void killa_granata(Granata* granate, int array_pid[]){
    //controllo per killare il processo granate una volta morte
    if (granate[0].alive==0 && granate[1].alive==0 && array_pid[IDGRANATE]!=0) { 
	   
	killProcess(array_pid[IDGRANATE]);	
	array_pid[IDGRANATE]=0;
    }

}

void controllo_stato_coccodrillo(int id,Coccodrillo* coccodrilli){

    if ((coccodrilli[id].x>=POS_SPAWN_COC_DESTRA && coccodrilli[id].dir==1) || (coccodrilli[id].x<=POS_SPAWN_COC_SINISTRA && coccodrilli[id].dir==-1)) {	//verifichiamo se il coccodrillo è all'interno della mappa
		    coccodrilli[id].alive=0;  //coccodrillo fuori dalla mappa = non attivo/morto
		} else {  
		    coccodrilli[id].alive=1;  //coccoddrillo dentro alla mappa = attivo/vivo
		}


}


void collisione_GranataProiettile(int pipe2, Granata* granate, Proiettile proiettili[], int array_pid[], Game_struct* game_struct){

    
	for (int i=0; i<2; i++) {
	    for(int j=0; j<15;j++){
	    
		    if (granate[i].x==proiettili[j].x && granate[i].y==proiettili[j].y && proiettili[j].alive==1 && granate[i].alive==1) {
			killProcess(array_pid[IDPROIETTILE+j]);  //killiamo il proiettile
			array_pid[IDPROIETTILE+j]=0;
			//impostiamo a morti il proiettile e la granata
			proiettili[j].alive=0;
			granate[i].alive=0;
			granate[i].x=-1;
			write(pipe2,&i, sizeof(int));  //avverte il processo granata che una delle granate è morta
			game_struct->score+=5;
	 	    }
	    }
	}


}


void attesa_coccodrilli(int id, Coccodrillo* coccodrilli, int distanze_coc[], int array_pid[]){
    int indice_flusso;
    //gestione dello stato di attesa 
		if ((coccodrilli[id].x==POS_SPAWN_COC_DESTRA && coccodrilli[id].dir==-1) || (coccodrilli[id].x==POS_SPAWN_COC_SINISTRA && coccodrilli[id].dir==1)) {  //controlliamo che il coccodrillo corrente si trova a inizio tragitto			
		    for (int i=0;i<MAX_CROCODILES;i++) {
		        indice_flusso=(coccodrilli[i].y-37)/-3;  //individuiamo l'indice del flusso del coccoddrillo corrente
					
			//controlliamo se il coccodrillo attuale stia spawnando con coccodrilli troppo vicini nelle stesso flusso
			if (i!=coccodrilli[id].id && coccodrilli[i].y==coccodrilli[id].y && ((coccodrilli[id].x-distanze_coc[indice_flusso]<coccodrilli[i].x && coccodrilli[id].dir==-1) || (coccodrilli[id].x+distanze_coc[indice_flusso]>coccodrilli[i].x && coccodrilli[id].dir==1)) && coccodrilli[i].wait!=1){
						
			   coccodrilli[id].wait=1;    //lo mettiamo in wait perchè ci sono coccodrilli non in wait vicino a dove spawna
		
			   kill(array_pid[id],SIGSTOP);  //lo fermiamo finchè questa situazioni permane
			}
		    }
		}

}

void riattivare_coccodrilli(Coccodrillo* coccodrilli, int distanze_coc[], int array_pid[]){

    int indice_flusso;
    int riattivare;
    for (int i=0;i<MAX_CROCODILES;i++) {  //controlliamo se dobbiamo sbloccare qualche coccodrillo
		    if (coccodrilli[i].wait==1) {
			indice_flusso=(coccodrilli[i].y-37)/-3;
		        	
			riattivare=1;
			
			for (int j=0;j<MAX_CROCODILES;j++) {  //per ogni coccodrillo in wait controlliamo se ci sono ancora coccodrilli nelle vicinanze (quelli in wait non contano)
			    if(i!=j && coccodrilli[j].y==coccodrilli[i].y && ((coccodrilli[i].x-distanze_coc[indice_flusso]<coccodrilli[j].x && coccodrilli[i].dir==-1) || (coccodrilli[i].x+distanze_coc[indice_flusso]>coccodrilli[j].x && coccodrilli[i].dir==1)) && coccodrilli[j].wait!=1){
			        riattivare=0;
			        break; 
			    }		
			}
			if (riattivare) {	  	  
			    distanze_coc[indice_flusso]=rand_funz(13,16);    //modifichiamo la distanza da rispettare così da aggiungere diversità						
			    	
			    coccodrilli[i].wait=-1;    //togliamo la wait e lo facciamo ripartire;
			    kill(array_pid[i],SIGCONT);	
			}
		    }
		}




}

void collisione_ProiettileBordi(int array_pid[], Proiettile proiettili[]){
    for(int i=0; i<15; i++){
    
	    if((proiettili[i].x<1 || proiettili[i].x>LARGHEZZA_GIOCO-2) && proiettili[i].alive==1){
		
			killProcess(array_pid[IDPROIETTILE+i]);
			array_pid[IDPROIETTILE+i]=0;
			proiettili[i].alive=0;
		}

    }
}

void collisione_GranataBordi(int pipe2, Granata* granate){
    
    
    for (int i=0; i<2;i++) {
	if((granate[i].x<1 || granate[i].x>LARGHEZZA_GIOCO-2) && granate[i].alive==1 && granate[i].x!=-1) {
	    granate[i].alive=0;
	    granate[i].x=-1;  
	    write(pipe2,&i, sizeof(int));  //scriviamo al processo granate quale delle due granate è morta
	    	
	}
    }

}

//funzione che mostra la barra del tempo rimanente
void print_tempo(WINDOW* game,Game_struct* game_struct, int tempo){

    wattron(game, COLOR_PAIR(7));
    mvwhline(game,46,15, ' ', (int)(62*((float)game_struct->tempo/tempo)));
    wattroff(game, COLOR_PAIR(7));
	

}


//funzione che controlla se la rana si trova in mappa
int RanaInFinestra(Rana* rana, Temp* temp){

    if(rana->x+temp->x>78) return 0;
    if(rana->x+temp->x<2) return 0;
    if(rana->y+temp->y>43) return 0;
    if(rana->y+temp->y<7) return 0;
    return 1;

}

//funzione di controllo collisione rana-proiettile
int CollisioneRanaProiettile(Rana*rana,Proiettile proiettili[], Game_struct* game_struct, int fine_manche){

    for(int i=0;i<15;i++){
    
    
    
	    if((rana->x+1==proiettili[i].x || rana->x-1==proiettili[i].x) && rana->y==proiettili[i].y && proiettili[i].alive) {
		game_struct->vite--;
		game_struct->score-=15;
		return 0;
	    }
    }
    
    return fine_manche;
       
}

//funzione di controllo se la rana è su una tana
int RanaSuTana(Rana* rana, Game_struct* game_struct){
	 
    for (int i=0;i<5;i++) {
        if (rana->x>=8+(15)*i && rana->x<8+(15)*i+5 && game_struct->tane[i]==0) {
   	    game_struct->tane[i]=1;
 	    return 1;
 	}
    }
    return 0;
}
	 	
	 	
	 		 

//funzione che svuota la pipe 
void svuota_pipe(int pipe_fd){
	
    int a;
    while (read(pipe_fd,&a,sizeof(int))!= -1) {  //leggiamo dalla pipe finchè non è vuota
	
    }
    
}




//funzione che verifica se la rana è su un coccodrillo
int RanaSuCoccodrillo(Rana* rana, Coccodrillo *coccodrilli){
    for (int i = 0; i < MAX_CROCODILES; i++) {
        if (coccodrilli[i].alive && rana->y == coccodrilli[i].y &&  rana->x-1>= coccodrilli[i].x-4 && rana->x+1 <= coccodrilli[i].x+4) {
            
            return coccodrilli[i].id; 
            
        }
    }
    return -1; 
}




//funzione di creazione dei processi
void creazione_processi(Flusso *flussi, int array_pid[N_PID], int pipe1[], WINDOW* game){
	
    for (int i=0;i<N_PID;i++) {
	array_pid[i]=0;  //settiamo tutti i pid a 0 per cominciare a creare i processi
    }	

    array_pid[IDRANA]=fork();  //creaiamo il processo rana
    if (array_pid[IDRANA]==-1) {
	perror("Erorre nella fork della rana : ");
	exit(1);
    } else if (array_pid[IDRANA]==0) {
	frog(game,pipe1); 

    } else {  
        array_pid[IDTIME]=fork();  //creiamo il processo del tempo
	if (array_pid[IDTIME]==-1) {
	    perror("Erorre nella fork della rana : ");
	    exit(1);
	} else if (array_pid[IDTIME]==0) {
	    tempo(pipe1);
	} else {
	    array_pid[MAX_CROCODILES]=fork();  //creiamo il processo che gestisce la creazione dei coccodrilli
	    if (array_pid[MAX_CROCODILES]==-1) {
		perror("Errore nella fork del generatore coccodrilli: ");
		exit(-1);
	    } else if (array_pid[MAX_CROCODILES]==0) {
	        funzione_gestione_coccodrilli(flussi,pipe1);
	        exit(-1);
	    } else return;
	}
    }
}

//funzione che assegna una velocità a ogni flusso
void def_vel_flussi(Flusso *flussi, int vel){
	
    
    int altezza_base=37;  //posizione del primo flusso (quello più in basso)
    int dimensione_flussi=3;  //larghezza dei flussi
    for (int i=0;i<8;i++) {
        flussi[i].y=altezza_base - i*dimensione_flussi;
	flussi[i].speed= rand_funz(vel - 10000,vel+10000);
    }
}




//funzione che assegna una direzione ad ogni flusso
void def_dir_flussi(Flusso *flussi){
    for (int i=0;i<8;i++) {
	if (i>=1) {  //tutti i flussi dal secondo in poi hanno direzione opposta al flusso precedente
	    flussi[i].dir= -flussi[i-1].dir;

	} else {
	    //impostiamo la direzione del primo flusso in modo randomico
	    flussi[i].dir= rand()%2;
	    if (flussi[i].dir==0) flussi[i].dir=1;
	    else flussi[i].dir=-1;
	}
    }	
}

//funzione gestione proiettile
void funz_proiettile(int id, Coccodrillo coccodrillo,int vel,int pipe1[]){   
    close(pipe1[0]);
    Temp proiettile={IDPROIETTILE+id,0,0,0};
	
    //impostiamo il proiettile in base al coccodrillo che lo ha sparato
    if (coccodrillo.dir==1) proiettile.x=coccodrillo.x+5;
    else proiettile.x=coccodrillo.x-5;	
    proiettile.y=coccodrillo.y;	

    while (true) {

	    
        write(pipe1[1], &proiettile, sizeof(Temp));  			
        proiettile.x+=coccodrillo.dir;
        usleep(vel);
	
    }
}

//funzione di gestione dei coccodrilli
void funzione_gestione_coccodrilli(Flusso *flussi,int pipe1[]){
    close(pipe1[0]);
    
    int numero_coc_flussi[8]={0};
    int flusso_random;
    Temp coccodrillo;
    Temp messaggio;   
    pid_t pid_coc;
    
    for(int i=0;i<MAX_CROCODILES;i++){
    
        do {
            flusso_random=rand_funz(0,7);
           
        }while(numero_coc_flussi[flusso_random]==3);  //cerchiamo un flusso random che abbia meno di 3 coccodrilli;
   
   
   
   
       	
	//imposto il coccodrillo
	coccodrillo.id=i;
	coccodrillo.info=0;
	coccodrillo.y=flussi[flusso_random].y;
	
	numero_coc_flussi[flusso_random]++;  //aumentiamo di uno il numero di coccodrilli nel flusso selezionato
	
	if (flussi[flusso_random].dir==1) {
	    coccodrillo.x=POS_SPAWN_COC_SINISTRA-1;   
	} else {
	    coccodrillo.x=POS_SPAWN_COC_DESTRA+1;
	}
	
	pid_coc=fork();
	if (pid_coc==-1) {
	    perror("Errorre nella fork coccodrillo: ");
	    exit(1);
	} else if (pid_coc==0) {
		funzione_coccodrillo(coccodrillo,flussi,flusso_random,pipe1);
	} else {
	    
	    messaggio.info=pid_coc;  //impostiamo il messsaggio fa inviare
	    messaggio.id=i;
	    messaggio.y=IDAGGIUNTAPID;  //serve per far capire che è un nuovo pid da aggiungere nella lista dei pid;      
	
	    write(pipe1[1], &messaggio,sizeof(Temp));                            
	    usleep(rand_funz(500000,800000));}
	    if (i== MAX_CROCODILES/2) {
		usleep(rand_funz(2000000,3000000));  //a metà della creazione dei coc fermiamo la loro generazione per qualche secondo, così da aumentare la randomicità;
	    }
    } 
}	
  
  

//funzione i controllo del coccodrillo
void funzione_coccodrillo(Temp coccodrillo,Flusso flussi[8],int id_flusso_scelto, int pipe1[]){
    
    usleep(rand_funz(100000,300000));  
    coccodrillo.info=flussi[id_flusso_scelto].dir;
    
    
    while (true) {

	
	coccodrillo.x=coccodrillo.x+flussi[id_flusso_scelto].dir;
	write(pipe1[1], &coccodrillo, sizeof(Temp)); 
	usleep(flussi[id_flusso_scelto].speed);
	
	
	//se il coccodrillo esce fuori dalla mappa allora deve prepararsi a ricomciare il suo tragitto dall'inizio del flusso
	if ((coccodrillo.x>=POS_SPAWN_COC_DESTRA && flussi[id_flusso_scelto].dir==1) || (coccodrillo.x<=POS_SPAWN_COC_SINISTRA && flussi[id_flusso_scelto].dir==-1)) {  
	  
	
	    if (flussi[id_flusso_scelto].dir==1) {
	    
	        coccodrillo.x=POS_SPAWN_COC_SINISTRA-1;
	        
	    } else {
	    
	        coccodrillo.x=POS_SPAWN_COC_DESTRA+1;
	    }
	    usleep(rand_funz(500000,2000000));
	}
	    	
    }
}



//funzione che gestisce il tempo
void tempo(int* pipe1){
    close(pipe1[0]);
    Temp tempo={0,0,0,0};		
    tempo.id=IDTIME;
    while(true) {
	sleep(1);
	write(pipe1[1], &tempo, sizeof(Temp)); //manda un messaggio alla funzione di controllo ogni secondo
    }

    _exit(0);
}
	

   
//funzione per killare un processo
void killProcess(pid_t pid){
    int status;
    if(kill(pid, SIGKILL)!=0) {
	perror("errore nel killare il processo: ");
	exit(-1);
    } else {
        waitpid(pid, &status, 0);
    }
}

//funzione per killare più processi
void kill_processi(pid_t pid[N_PID]) {
	
    for (int i=0; i<N_PID;i++) {
	if(pid[i]>0) {
	    if(kill(pid[i],SIGKILL)!=0) {
		perror("Errore nel killare i processi: ");
		exit(-1);
	    } else {
	        waitpid(pid[i], NULL, 0);
	        pid[i]=0;
	    }
	}			
    }
}
   	
 


int menu(WINDOW *game, const char *title, const char *options[], int num_options){
    flushinp();  //elimina input residuo
    keypad(game, true);  //abilita l'input da tastiera

    int position = 0;
    int gameLINES = getmaxy(game);
    int gameCOLS = getmaxx(game);

    while (true) {
        wclear(game);
        box(game, ACS_VLINE, ACS_HLINE);

        mvwprintw(game, gameLINES / 2 - 5, gameCOLS / 2 - strlen(title)/2, "%s", title);
        for (int i = 0; i < num_options; i++) {
            if (position == i) {
                wattron(game, COLOR_PAIR(9));
            }

            int x = gameCOLS / 2 - (strlen(options[i]) / 2);
            mvwprintw(game, gameLINES / 2 - 1 + i, x, "%s", options[i]);

            
            wattroff(game, COLOR_PAIR(9));
        }

        int choice = wgetch(game);
        switch (choice) {
            case KEY_DOWN:
                position++;
                if (position >= num_options) position = 0;
                break;
            case KEY_UP:
                position--;
                if (position < 0) position = num_options-1;
                break;
            case 10: // Invio
                return position;
        }

        wrefresh(game);
    }
}


//funzione che mostra i crediti
void credits(WINDOW *game){
    wclear(game);
    box(game, ACS_VLINE, ACS_HLINE);

    int gameLINES = getmaxy(game);
    int gameCOLS = getmaxx(game);

    mvwprintw(game, gameLINES / 2 - 2, gameCOLS / 2 - 15, "Marta Viglietti");
    mvwprintw(game, gameLINES / 2 - 1, gameCOLS / 2 - 15, "Gabriele Stampatori");
    mvwprintw(game, gameLINES / 2 + 1, gameCOLS / 2 - 17, "Premi un tasto per tornare al menu...");

    wrefresh(game); 
    wgetch(game);
}


//funzione utile per creare un numero random tra un minimo e un massimo (compresi)
int rand_funz(int min, int max){

    return min + rand() % (max-min+1);

}











void frog(WINDOW* game,int pipe1[2]){
    close(pipe1[0]);
    
    int key;
    Temp rana={IDRANA,0,0,0};  //messaggio usato per inviare alla funzione di controllo i movimenti della rana     
    Temp granata={IDGRANATE+2,0,0,0};  //messaggio con id apposito per la creazione delle granate
    keypad(game, true);
    

    while (true) {
    
        //Cattura l'input da tastiera
        key = (int)wgetch(game);
        rana.x=0;
        rana.y=0;

        switch (key) {
            case KEY_UP:  //movimento verso l'alto
                rana.y=-3;
                write(pipe1[1], &rana, sizeof(Temp));
                break;		
                	
            case KEY_DOWN:  //movimento verso il basso
                rana.y=3;
                write(pipe1[1], &rana, sizeof(Temp));
                break; 		
  
               
            case KEY_LEFT:  //movimento verso sinistra
                rana.x=-2;
                write(pipe1[1], &rana, sizeof(Temp));		
                break;
                
            case KEY_RIGHT:  //movimento verso destra
                rana.x=2;
                write(pipe1[1], &rana, sizeof(Temp));		
                break;
            case 's':  //tasto per sparare le granate 
            	
            	write(pipe1[1],&granata,sizeof(Temp));  //mandiamo messaggio alla funzione di controllo indicando che abbiamo l'intenzione di sparare le granate
                
                break;
         
        }  
    }
}


//funzione che gestisce la creazione del processo granata
void sparaGranata(int startX, int startY,int velocità_proiettile ,int pid_array[],int pipe1[], int pipe2[]){

    pid_array[IDGRANATE]= fork(); //Crea un nuovo processo per la granata

    if (pid_array[IDGRANATE] < 0) {
        perror("Errore nella creazione del processo granata");
        exit(0); 
    }

    if (pid_array[IDGRANATE] == 0) {  
        
        granata(startX, startY,velocità_proiettile, pipe1,pipe2);  //chiamiamo la funzione granata all'interno del processo figlio
    }
}


//funzione che gestisce la creazione del processo proiettile
void sparaProiettile(int id,int identificatore_coc, Coccodrillo* coccodrilli,int velocità_proiettile, int pid_array[], int pipe1[]){
    pid_array[IDPROIETTILE+id]= fork(); // Crea un nuovo processo per la granata

    if (pid_array[IDPROIETTILE+id] < 0) {
        perror("Errore nella creazione del processo proiettile");
        exit(-1);
    }

    if (pid_array[IDPROIETTILE+id] == 0) {
   
        funz_proiettile(id,coccodrilli[identificatore_coc],velocità_proiettile,pipe1);  //chiamiamo la funzione proiettile all'interno del processo figlio
       
    }
}



//funzione che gestisce il processo granata
void granata(int startX, int startY, int velocità_proiettile, int pipe1[], int pipe2[]){		
    						
    close(pipe2[1]);
    close(pipe1[0]);
    Temp granate[2];
    int messaggio;
    //variabili che gestiscono lo stato delle granate
    int alive_destra=1;
    int alive_sinistra=1;
   
    //impostazione iniziale delle granate (id e posizione di partenza)
    granate[0].id=IDGRANATE; 
    granate[1].id=IDGRANATE + 1;
    granate[0].x=startX - 2;
    granate[1].x=startX + 2; 			
    granate[0].y=startY;
    granate[1].y=startY;   
    granate[0].info=0;
    granate[1].info=0;
    
    svuota_pipe(pipe2[0]);
    

    while (true) {
    	
    	
    	while(read(pipe2[0],&messaggio,sizeof(int))!=-1){  //leggiamo se ci sono messaggi dalla funzioni di controllo per granate morte
            if (messaggio){
                
                alive_destra=0;
            } else { 
                alive_sinistra=0;
                	
            }
        }
        if (alive_destra) {
	    write(pipe1[1],&granate[1],sizeof(Temp));	 
	    granate[1].x++; 
	}
        	
        if (alive_sinistra) {
	    write(pipe1[1],&granate[0],sizeof(Temp));
	    granate[0].x--;
	}
        usleep(velocità_proiettile);  
    }
 	       
        
}

//funzione che crea i colori utilizzati durante il gioco
void creazione_colori(){
    if (has_colors()) { //verifica il supporto ai colori da parte del terminale
        start_color();
        init_color(8,0,300,0);       //verde foresta
   	init_color(9,0,123,184);     //blu scuro		
  	init_color(10,95,95,95);     //grigio scuro
  	init_color(11,192,192,192);  //grigio chiaro
   	init_color(12,101,67,33);    //marrone
   	init_color(13,230,118,84);   //marrone pastello
   	init_color(14,50,300,50);    //verde chiaro
        init_color(15,0,500,0);      //verde chiaro
        init_color(16, 150,200,0);   //verde scuro
        init_color(17,100,500,700);  //blu chiaro
        init_color(18,800,800,0);  //giallo chiaro
        init_color(19,350,350,350);  //grigio 
        init_color(20,0,400,0);    //verde chiaro
        
    	init_pair(1,COLOR_BLACK,20);               //rana
   	init_pair(2, COLOR_BLUE, 17);	           //fiume
   	init_pair(3, 19, COLOR_YELLOW);  //zona in torno alle tane
   	init_pair(4, 10, 11);                      //recinzione delle tane
    	init_pair(5, 13, 13); 		           //tana vera e propria
   	init_pair(6, COLOR_YELLOW, 16);            //marciapiede
   	init_pair(7, COLOR_WHITE, COLOR_MAGENTA);  //punteggio e vite	
   	init_pair(8, 8, 15);   	                   //prato;
        init_pair(9,COLOR_BLACK,COLOR_WHITE);	   //selezione menù
        init_pair(10,COLOR_BLACK,14);              //coccodrillo
        init_pair(11,COLOR_RED,17);	   //proiettile
        init_pair(12,COLOR_RED,15);    //granata nel prato
        init_pair(13,COLOR_RED,17);	   //granata fiume
        init_pair(14,COLOR_RED,COLOR_RED); 	   //zona esterna al gioco
        init_pair(15,COLOR_WHITE,14);		   //colore score-vite-tempo
        init_pair(16,COLOR_BLACK,18);      //occhi rana e coccodrilli    
        init_pair(17,COLOR_RED,16);     //granata nel marciapiede 
                
    } else {  //il terminale non supporta i colori
    	printw("Il terminale non permette la visualizzazione dei colori\n"); 
    	mvprintw(LINES-1/2,COLS/2,"Premi un tasto per uscire...");refresh();
    	getch();
    	_exit(0);
    }
	
	
}




//funzione per disegnare il proiettile nella mappa
void draw_proiettile(WINDOW* game, Proiettile proiettili[]){
    
    for(int i=0; i<15;i++){
	    if (proiettili[i].alive) {  //mostriamo il proiettile solo se vivo		
		wattron(game,COLOR_PAIR(11));
		
		    mvwaddch(game,proiettili[i].y,proiettili[i].x,'*');		
		
		wattroff(game,COLOR_PAIR(11));
		}
    }		
}




void draw_granate(WINDOW* game, Granata granate[2]){
	
	
    for (int i=0;i<2;i++) {
	if (granate[i].alive && granate[i].x!=-1) { //mostriamo le granate solo se vive
				
	    if (granate[i].y<15 && granate[i].y>=10) {  //granata sul marciapiede
		wattron(game,COLOR_PAIR(6));
		mvwaddch(game,granate[i].y,granate[i].x,'O');
		wattroff(game,COLOR_PAIR(6));			
	    }
	    if (granate[i].y<40 && granate[i].y>=15) {  //granata sul fiume
		wattron(game,COLOR_PAIR(13));
		mvwaddch(game,granate[i].y,granate[i].x,'O');
		wattroff(game,COLOR_PAIR(13));
	    }	
	    if (granate[i].y<45 && granate[i].y>=40) {  //granata sul prato
		wattron(game,COLOR_PAIR(12));
		mvwaddch(game,granate[i].y,granate[i].x,'O');
		wattroff(game,COLOR_PAIR(12));
            }
	}
    }
}

//funzione che disegna la rana
void draw_frog(WINDOW *game, Rana* rana){
	
    
    wattron(game,COLOR_PAIR(1));
    
    for (int i = 0; i < ALTEZZARANA; i++) {
        for (int j = 0; j < LARGHEZZARANA; j++) {			
            mvwaddch(game, rana->y + i, rana->x -1 + j, frog_sprite[i][j]);
        }
    }
    wattron(game,COLOR_PAIR(16));
    mvwaddch(game, rana->y, rana->x -1, frog_sprite[0][0]);
    mvwaddch(game, rana->y, rana->x + 1, frog_sprite[0][2]);
    wattroff(game,COLOR_PAIR(16));
}






//funzione che disegna i coccodrilli
void drawCoccodrilli(WINDOW *game, Coccodrillo *coccodrilli){
    int h;  //variabile utilizzata per tenere conto di quale parte del coccodrillo stiamo printando (inferiore o superiore)
    wattron(game, COLOR_PAIR(10));
    
    for (int i = 0; i < MAX_CROCODILES; i++) {
        if (coccodrilli[i].alive && coccodrilli[i].dir==1 && coccodrilli[i].wait!=1) { //coccodrillo vivo, non in wait e direzionato verso destra
          
            h=0; 
	    
	    //printiamo la parte superiore del coccodrillo
            for (int j = 0; j < LARGHEZZACOCCODRILLO-2; j++) {
	        if (coccodrilli[i].x-3+j>0 && coccodrilli[i].x-3+j<LARGHEZZA_GIOCO-1) {  //condizioni necessarie per printare solo le parti del coccodrillo all'interno della mappa	
	            
	                mvwaddch(game, coccodrilli[i].y, coccodrilli[i].x -3 + j, coc_sprite[0][h][j]);
	        }
	       	      
    	    }
   	    
            h=1;
            
            //printiamo la parte inferiore del coccodrillo
            for (int j = 0; j < LARGHEZZACOCCODRILLO; j++) {
       	        if (coccodrilli[i].x-4+j>0 && coccodrilli[i].x-4+j<LARGHEZZA_GIOCO-1) {		
       	            if(coc_sprite[0][h][j]=='0'){
	                wattron(game, COLOR_PAIR(16));
	                mvwaddch(game, coccodrilli[i].y + h, coccodrilli[i].x -4 + j, coc_sprite[0][h][j]);
	                wattroff(game, COLOR_PAIR(16));
	                
	                wattron(game, COLOR_PAIR(10));
	            
	            } else {	
       		     	mvwaddch(game, coccodrilli[i].y + h, coccodrilli[i].x -4 + j, coc_sprite[0][h][j]);
     	    	    }
   	        }
           
            }
        } else if (coccodrilli[i].alive && coccodrilli[i].dir==-1 &&  coccodrilli[i].wait!=1) {   //coccodrillo vivo, non in wait e direzionato verso sinistra
       	    
       	    h=0; 
            
            
            //printiamo la parte superiore del coccodrillo
            for (int j = 0; j < LARGHEZZACOCCODRILLO-2; j++) {
	        if (coccodrilli[i].x-3+j>0 && coccodrilli[i].x-3+j<LARGHEZZA_GIOCO-1) {			
	     	    mvwaddch(game, coccodrilli[i].y + h, coccodrilli[i].x -3 + j, coc_sprite[1][h][j]);   //prima riga , colonna h, al carattere n j;
    		}
   	    }
            h=1;
            
            //printiamo la parte inferiore del coccodrillo
            for (int j = 0; j < LARGHEZZACOCCODRILLO; j++) {
       		   if (coccodrilli[i].x-4+j>0 && coccodrilli[i].x-4+j<LARGHEZZA_GIOCO-1) {			
       		     	
       		     	if(coc_sprite[1][h][j]=='0'){
			        wattron(game, COLOR_PAIR(16));
			        mvwaddch(game, coccodrilli[i].y + h, coccodrilli[i].x -4 + j, coc_sprite[1][h][j]);
			        wattroff(game, COLOR_PAIR(16));
			        
			        wattron(game, COLOR_PAIR(10));
	            
	                } else {
       		     	    mvwaddch(game, coccodrilli[i].y + h, coccodrilli[i].x -4 + j, coc_sprite[1][h][j]);
     	    	        }
     	    	   }
     	          	    
   	    }
   	    
   	    
        }
    }
    wattroff(game, COLOR_PAIR(10));
    
}



//funzione che sblocca le pipe
void sblocca_fd(int fd) {

    int flags = fcntl(fd, F_GETFL);
    if (flags == -1) {
        perror("Errore nell'ottenere i flag del fd");
        exit(-1);
    }
    if (fcntl(fd, F_SETFL, flags | O_NONBLOCK) == -1) {
        perror("Errore nel settare O_NONBLOCK");
        exit(-1);
    }
}


//funzione che blocca le pipe
void blocca_fd(int fd) {

    int flags = fcntl(fd, F_GETFL);
    if (flags == -1) {
        perror("Errore nell'ottenere i flag del fd");
        exit(-1);
    }
    flags &= ~O_NONBLOCK;
    if (fcntl(fd, F_SETFL, flags) == -1) {
        perror("Errore nel rimuovere O_NONBLOCK");
        exit(-1);
    }
}
