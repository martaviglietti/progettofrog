#include <stdio.h>
#include <time.h>
#include <stdlib.h>
#include <unistd.h>
#include <ncurses.h>
#include <sys/wait.h>
#include <sys/time.h>
#include <locale.h>
#include "menu.h"
#include <string.h>
#include <fcntl.h>
#define MAX_CROCODILES 24
#define LARGHEZZA_GIOCO 81
#define ALTEZZA_GIOCO 49
#define POS_SPAWN_COC_SINISTRA -4
#define POS_SPAWN_COC_DESTRA 84
#define ALTEZZARANA 2
#define LARGHEZZARANA 3
#define ALTEZZACOCCODRILLO 2
#define LARGHEZZACOCCODRILLO 9
#define DELAY 100000
#define TANE 6
#define FIUME 25
#define PRATO 5
#define SPONDA_SUPERIORE 5
#define N_PID 100
//definizione id da usare;
#define IDTIME 45
#define IDCOC 0
#define IDRANA 50
#define IDGRANATE 60
#define IDPROIETTILE 70
#define IDAGGIUNTAPID 80
#define IDMORTE -10
#define IDRICHIESTA 90


// Opzioni del menu
static const char *OPZIONI[] = {
    "Inizia gioco", "Crediti", "Esci"
};

//sprite rana
const char *frog_sprite[2] = {
    "@ @",
    " - "
};

const char *coc_sprite[2][2]={{"XXXXXXX","XXXXXX0X0"},{"XXXXXXX","0X0XXXXXX"}};
            


typedef struct{
    int id;
    int y;
    int dir;
    int speed;
}Flusso;




typedef struct{
    int vite;
    int score;
    int tempo;
    int tane[5];
    int game; //serve per la condizione di uscita dal game;
}Game_struct;

typedef struct{
    int vite;
    int tempo;
    int velocit√†_proiettili;
    int velocit√†_coccodrilli;
 
}Stat_game;

typedef struct{
    int id;
    int y;
    int x;
    int dir;
    int alive;
    int wait;
}Coccodrillo;

typedef struct{
    int id;
    int y;
    int x;
    int alive;
}Proiettile;

typedef struct{
    int id;
    int y;
    int x;
    int alive;
}Granata;



typedef struct{
    int id;
    int x;
    int y;
}Rana;

typedef struct{
	int id;
	int x;
	int y;
	int info;
}Temp;


int gameWin(WINDOW *game, int score);
int gameOver(WINDOW *game, int score);
int scegliDifficolta(WINDOW *game);
void windowGeneration(WINDOW *game, int maxX, int maxY, Game_struct* game_struct);
Game_struct startGame(WINDOW *game,Stat_game stat_game);
void Gestione_grafica(WINDOW* game,int pipe1[], int pipe2[], int array_pid[],int vel_proiettili, Game_struct* game_struct);
int CollisioneRanaProiettile(Rana rana,Proiettile proiettile);
int RanaSuTana(Rana rana, Game_struct* game_struct);
int RanaSuCoccodrillo(Rana *rana, Coccodrillo *coccodrilli);
void creazione_processi(Flusso *flussi, int array_pid[N_PID], int pipe1[],WINDOW* game);
void funzione_gestione_coccodrilli(Flusso *flussi,int pipe1[]);
void funzione_coccodrillo(Temp coccodrillo,Flusso flussi[8],int id_flusso_scelto, int pipe1[]);
void funz_proiettile(Coccodrillo coccodrillo,int vel_proiettile, int pipe1[]);
void tempo(int pipe1[]);
void kill_processi(pid_t* pid);
void def_vel_flussi(Flusso *flussi, int velocit√†_coccodrillo);
void def_dir_flussi(Flusso *flussi);
int menu(WINDOW *game, const char *title, const char *options[], int num_options);
void credits(WINDOW *game);
int rand_funz(int min, int max);
void frog(WINDOW* game,int pipe1[2]);
void sparaGranata(int startX, int startY,int vel_proiettile ,int pid_array[],int pipe1[], int pipe2[]);
void sparaProiettile(Coccodrillo coccodrillo,int vel_proiettile,int pid_array[], int pipe1[]);
void granata(int startX, int startY,int vel_proiettile,int pipe1[], int pipe2[]);
void creazione_colori();
void draw_proiettile(WINDOW* game, Proiettile proiettile);
void draw_granate(WINDOW* game, Granata granate[2]);
void draw_frog(WINDOW *game, Rana rana);
void drawCoccodrilli(WINDOW *game, Coccodrillo *coccodrilli);
void sblocca_fd(int fd);
void killProcess(pid_t pid);
int RanaInFinestra(Rana rana, Temp temp);
void blocca_fd(int fd);
void svuota_pipe(int pipe_fd);
void print_tempo(WINDOW* game,Game_struct* game_struct, int tempo);    
void punteggio_tempo(Game_struct* game_struct);         




int main(){
    printf("\e[8;%d;%dt", 49, 81);  //ridimensioniamo il terminale
    fflush(stdout);
    setlocale(LC_ALL, "");     // Abilita UTF-8	
    sleep(1);	

    //Inizializziamo ncurses
    initscr();
    noecho();
    cbreak();
    curs_set(0);
    resizeterm(49, 81);  //avvisiamo ncurses del cambio di dimensioni del terminale
    creazione_colori();    
    srand(time(NULL));
    
	
    int height = LINES;
    int width = COLS;
    
    int scelta;	     //variabile contenente la scelta dal men√π principale
    int difficolt√†;  //variabile contenente la difficolt√† scelta dal men√π delle difficolt√†
    int ricomincia=1;
    
    Stat_game stat_game={0,0,0,0};
    Game_struct risultato;  //conterr√† i risultati del game 
    WINDOW *game = newwin(height, width, 0, 0);  //finestra dell'area gioco  
    

    while (true){
    	if (ricomincia) {  //se 'ricomincia' √® 0 non torniamo al menu;
            scelta= menu(game,"Menu Principale", OPZIONI, 3);  //se 'ricomincia' √® 0 non torniamo al menu;
        }	
	
        if (scelta == 0) { 
         
   	    if (ricomincia) {  //se 'ricomincia' √® 0 manteniamo la stessa difficolt√†
                difficolt√†=scegliDifficolta(game);
            }
        
        
            switch (difficolt√†) {
                case 0:  //Facile
                    stat_game.vite=10;			   //numero vite
                    stat_game.tempo=100;		   //tempo di gioco
                    stat_game.velocit√†_proiettili=30000;   //velocit√† proiettili
                    stat_game.velocit√†_coccodrilli=200000;  //velocit√† coccodrilli
                    break;
                case 1:  //Medio
                    stat_game.vite=10;
                    stat_game.tempo=30;
                    stat_game.velocit√†_proiettili=30000;
                    stat_game.velocit√†_coccodrilli=50000;
                    break;
                case 2:  //Difficile
                    stat_game.vite=10;
                    stat_game.tempo=30;
                    stat_game.velocit√†_proiettili=3000;
                    stat_game.velocit√†_coccodrilli=50000;
                    break;      
            }
        
        
        
            risultato=startGame(game,stat_game);
            
            if (risultato.game==1) {  //Vittoria
                scelta=gameWin(game,risultato.score); 
            	
            	if (scelta) {	
            	    ricomincia=1;  //torna al men√π principale
            	} else {
            	    ricomincia=0;  //ricomincia il game con stessa difficolt√†
            	}	
            } else {  //Sconfitta
            	scelta=gameOver(game,risultato.score);
            	if (scelta) {					
            	    ricomincia=1;  //torna al men√π principale
            	} else {
            	    ricomincia=0;  //ricomincia il game con stessa difficolt√†
            	} 	
            }
        
        } else if (scelta==1) {  //crediti
            credits(game);
        	
        } else {  //Uscita
            wclear(game);
            mvwprintw(game, height / 2, width / 2 - 5, "Uscita...");
            wrefresh(game);
            sleep(1);
            break; // Esci dal programma
        }
    }

    delwin(game);
    endwin();
    return 0;
}

int gameWin(WINDOW *game, int score){  //schermata in caso di vittoria
    wclear(game);
    box(game, ACS_VLINE, ACS_HLINE);
    mvwprintw(game, 10, 10, "HAI VINTO! Punteggio: %d. Vuoi giocare ancora? (s/n)", score);
    wrefresh(game);
    char decision = wgetch(game);
    while (decision!= 's' && decision!='n') {
        decision = wgetch(game);
    }
    if (decision == 's') {  //se rispondiamo di si ripetiamo il game (con stessa difficolt√†) da capo
        return 0;
    } else {  //altrimenti torniamo al men√π
        return 1;
    }
}


int gameOver(WINDOW *game, int score){  //schermata in caso di perdita
    wclear(game);
    box(game, ACS_VLINE, ACS_HLINE);
    mvwprintw(game, 10, 10, "GAME OVER! Punteggio: %d. Vuoi giocare ancora? (s/n)", score);
    wrefresh(game);
    char decision = wgetch(game);
    while (decision!= 's' && decision!='n') {
    	 decision = wgetch(game);
    }
    if (decision == 's') {  //se rispondiamo di si ripetiamo il game (con stessa difficolt√†) da capo
        return 0;
    } else {  //altrimenti torniamo al men√π
        return 1;
    }
}



int scegliDifficolta(WINDOW *game) {  //schermata per scelta della difficolt√†
    const char *difficolta[] = {"Facile", "Media", "Difficile"};
    return menu(game, "Scegli la Difficolt√†", difficolta, 3);
}


void windowGeneration(WINDOW *game, int maxX, int maxY, Game_struct* game_struct){
    
    box(game, ACS_VLINE, ACS_HLINE);
    int offsetSumV=0;  //variabile che tiene conto della posizione di stampa
    int offsetSumH=1;  //variabile per ignorare il bordo laterale
    
    //Definiamo la mappa di gioco
    char tane[TANE][LARGHEZZA_GIOCO-2]={
        "                                                                               ",
    	"                                                                               ",
    	"     +-------+      +-------+      +-------+      +-------+      +-------+     ",		          
    	"     |.......|      |.......|      |.......|      |.......|      |.......|     ",			
    	"     |.......|      |.......|      |.......|      |.......|      |.......|     ",
    	"     |.......|      |.......|      |.......|      |.......|      |.......|     "
    };	
    							 
    char fiume[FIUME][LARGHEZZA_GIOCO-2]={
 	"                                                                               ",
    	"              ~                                                                ",
    	"                         ~                ~          ~                 ~       ",
    	"        ~                     ~                                                ",
    	"                                                        ~          ~           ",
    	"                                    ~                                          ",
    	"                                               ~                               ",
    	"                ~            ~                                                 ",
    	"                                                        ~                      ",
    	"                                             ~                                 ",	
    	"         ~                      ~                                              ",
    	"                                                                   ~           ",
    	"                                                                               ",
    	"                     ~                    ~          ~                         ",
    	"                                                                               ",
    	"                                                          ~                    ",
    	"             ~            ~          ~            ~                     ~      ",
    	"                                                                               ",
    	"                                                                ~              ",
    	"                                ~           ~                                  ",
    	"         ~                                                                     ",
    	"                                                                               ",
    	"              ~            ~                           ~                       ",
    	"                                      ~                       ~     ~          ",
    	"                                                                               "
    };     
    
    char prato[PRATO][LARGHEZZA_GIOCO-2]={   
    
    	"                                                                               ",
    	"                   /          |                      /          .     \\        ",
    	"       .                                         .                             ",
    	"                 .                 .                       \\          .        ",
    	"                          /                     /                              "
    };
    
    offsetSumV += 4; 
    
    //Sezione Tane
    
    //Printiamo zona intorno alle tane
    wattron(game,COLOR_PAIR(3));
    for (int i=0; i<TANE;i++) {
    	for (int j=0; j<maxX-2;j++) {				
    	    if (tane[i][j]==' ' ) {  		
    	        mvwaddch(game,i+offsetSumV,j+offsetSumH,tane[i][j]);
            }
        }
    }
    wattroff(game,COLOR_PAIR(3));
    
    //Printiamo le tane
    
    for(int i=0; i<5;i++){
	if(game_struct->tane[i]==0){
            wattron(game,COLOR_PAIR(4));
	    for (int v=2; v<TANE;v++) {
	    	for (int h=5+(8+7)*i; h<5+(8+7)*i+9 ;h++) {							
	    	    if (tane[v][h]=='|' || tane[v][h]=='+' || tane[v][h]=='-') {				
	    	     	 mvwaddch(game,v+offsetSumV,h+offsetSumH,tane[v][h]);
	            }
	       	}
 	    }
	    wattroff(game,COLOR_PAIR(4));
	    wattron(game,COLOR_PAIR(5));
	    for (int v=2; v<TANE;v++) {
	    	for (int h=5+(8+7)*i; h<5+(8+7)*i+9 ;h++) {
	    	    if (tane[v][h]=='.') {									
	    	        mvwaddch(game,v+offsetSumV,h+offsetSumH,tane[v][h]);
	   	    }
	   	}
	    }
	    wattroff(game,COLOR_PAIR(5));
    
	} else {
	    
	    wattron(game,COLOR_PAIR(3));
	    for (int v=2; v<TANE;v++) {
		for (int h=5+(8+7)*i; h<5+(8+7)*i+9 ;h++) {								
	     	    mvwaddch(game,v+offsetSumV,h+offsetSumH,'\0');
		}
	    }
	    wattroff(game,COLOR_PAIR(3));    
	}
    }
    
    offsetSumV += TANE;  
    
    //Sezione sponda superiore
    
    wattron(game, COLOR_PAIR(6)); 
    for (int i = 0; i < SPONDA_SUPERIORE; i++) {
        mvwhline(game, offsetSumV + i, offsetSumH, ' ', maxX - 2);
    }
    wattroff(game, COLOR_PAIR(6));
   
    offsetSumV += SPONDA_SUPERIORE;  


    //Sezione Fiume
    
    wattron(game,COLOR_PAIR(2));
    for (int i=0; i<FIUME;i++) {
        for (int j=0; j<maxX-2;j++) {										
    	    mvwaddch(game,i+offsetSumV,j+offsetSumH,fiume[i][j]);
        }
    }
    wattroff(game,COLOR_PAIR(2));
    
    offsetSumV += FIUME;  
    
    
    //Sezione Prato
    
    wattron(game,COLOR_PAIR(8));
    for (int i=0; i<PRATO;i++) {
    	for (int j=0; j<maxX-2;j++) {											
    	    mvwaddch(game,i+offsetSumV,j+offsetSumH,prato[i][j]);
        }
    }
    wattroff(game,COLOR_PAIR(8));
    
    //print zona esterna 
    wattron(game,COLOR_PAIR(14));
    mvwhline(game, 1,1, ' ', maxX - 2);
    mvwhline(game, 3,1, ' ', maxX - 2);
    mvwhline(game, 45,1, ' ', maxX - 2);  
    mvwhline(game, 47,1, ' ', maxX - 2);  
    mvwhline(game, 2,15, ' ', 35);
    mvwhline(game, 46,77, ' ', 3);
    mvwhline(game, 46,12, ' ', 3);
    mvwhline(game, 2,76, ' ', 4);
   
    mvwaddch(game,46,78,' ');
    mvwaddch(game,46,77,' ');
    mvwaddch(game,46,78,' ');
    mvwaddch(game,46,1,' ');
    mvwaddch(game,2,1,' ');
    
    wattroff(game,COLOR_PAIR(14));
    
};


Game_struct startGame(WINDOW *game,Stat_game stat_game){			
    
    //Creazione pipe;
    int pipe1[2];  //per comunicare tra consumatore e produttori;
    int pipe2[2];  //per comunicare alla granata se √® morta;
    pipe(pipe1);        
    pipe(pipe2);	
    sblocca_fd(pipe2[0]);  //sblocchiamo la pipe
   
    //Inizializziamo variabili di gestione della partita
    int tane_occupate=0;
    Game_struct game_struct;
    game_struct.score=0; 		//contiene lo score di tutto il game
    game_struct.vite=stat_game.vite;    //contiene numero di vite rimaste
    game_struct.tempo=stat_game.tempo;  //contiene tempo rimasto nella manche
   
    for (int i=0;i<TANE-1;i++) {
        game_struct.tane[i]=0;
    }
    
    Flusso flussi[8];
    def_vel_flussi(flussi,stat_game.velocit√†_coccodrilli); //definisco velocit√† di ogni flusso                
    int array_pid[N_PID];  //array contenente i pid dei processi creati  
    
    while (true) {
        
        def_dir_flussi(flussi);  //definisce direzione di ogni flusso					
    	creazione_processi(flussi,array_pid, pipe1,game);  //crea tutti i processi
	Gestione_grafica(game,pipe1,pipe2,array_pid,stat_game.velocit√†_proiettili,&game_struct);  //funzione di gestione grafica
    	game_struct.tempo=stat_game.tempo; 	
	svuota_pipe(pipe1[0]);  //svuotiamo la pipe per eliminare eventuali elementi rimasti all'interno
	
   	kill_processi(array_pid);		
   	
        //Controlli di fine manche
        if (game_struct.vite==0) { 
 	    game_struct.game=0;
 	    game_struct.score-=50;
 	    return game_struct;  //uscita per vite finite
	}
	
   	for (int i=0;i<5;i++) {
 	    if(game_struct.tane[i]==1){
  	        tane_occupate++;
  	    }
 	}
 	
 	if (tane_occupate==5) {		
 	    game_struct.game=1;
 	    game_struct.score+=100;
	    return game_struct;  //uscita per tane chiuse
 	}
	tane_occupate=0;
   
	wclear(game);
	wrefresh(game);     
	}
}


void Gestione_grafica(WINDOW* game,int pipe1[], int pipe2[], int array_pid[],int vel_proiettile, Game_struct* game_struct){			
	
    //Variabili per gestione proiettile
    struct timeval start, end; 
    gettimeofday(&end,NULL);		
    gettimeofday(&start,NULL);
    long time_proiettile; 
    int random=rand_funz(2,4);

    int result; //contiene il risultato delle funzioni di collisione;	 
    Temp temp={-1,0,0,0};
    int b=0;

    //Inizializzazione degli elementi di gioco
    Coccodrillo coccodrilli[MAX_CROCODILES];
    for (int i=0; i<MAX_CROCODILES;i++) {
        coccodrilli[i].id=i;      //id coccodrillo
	coccodrilli[i].x=-1;	  //posizione x coccodrillo
	coccodrilli[i].y=-1;      //posizione y coccodrillo
	coccodrilli[i].dir=0;     //direzione coccodrillo
	coccodrilli[i].alive=0;   //stato del coccoddrillo
	coccodrilli[i].wait=-1;}  //variabile per stato di attesa

    Granata granate[2];
    for (int i=0; i<2;i++) {
	granate[i].id=i;
	granate[i].x=-1;
	granate[i].y=-1;
	granate[i].alive=0;}
		
    Rana rana;	
    rana.id=IDRANA;
    rana.x=40; 
    rana.y=43;

    Proiettile proiettile;
    proiettile.id=IDPROIETTILE;
    proiettile.x=50;
    proiettile.y=-1;
    proiettile.alive=0;
   
    int tempo=game_struct->tempo;
    int coc_scelto;  //variabile utilizzata per indicare su quale coccodrillo posa la rana
    int granata_morta;
    int riattivare;
    int distanze_coc[8];
    for (int i=0; i<8;i++) {
	distanze_coc[i]=rand_funz(7,10);  //impostiamo le distanze iniziali tra coccodrilli per ogni flusso del fiume
    }
    int indice_flusso;
    
    while (true) {	
	
        read(pipe1[0],&temp,sizeof(Temp));  //leggiamo il messaggio nella pipe
	
	//se l'ID √® della rana						
	if (temp.id==IDRANA) {
	    if (RanaInFinestra(rana,temp)) {  //controllo per evitare che la rana fuoriesca dalla finestra di gioco
	        rana.x+=temp.x;
	        rana.y+=temp.y;	
	
		if (rana.y<10) {  //controllo se la rana si trova nella zona delle tane			
		    if (RanaSuTana(rana,game_struct)) {  //controllo se la rana si trova su una delle tane        
		        game_struct->score+=15;
			game_struct->score+=(int)(15*(float)game_struct->tempo/100);
			return;						
		    } else {  //altrimenti la rana si trova nella zona circostante alle tane
		        game_struct->vite--;
			game_struct->score-=10; 
			return;
		    }
		}
	    }  
        }
	
	//se l'id √® del processo tempo
	if (temp.id==IDTIME) {	
	    game_struct->tempo-=1;
	    if (game_struct->tempo==0) {  //controllo per verificare che il tempo non sia a zero
	        game_struct->vite--;
		game_struct->score-=20;
		return;
	    }
	}

	
	//se l'ID √® di un coccodrillo
	if (temp.id<MAX_CROCODILES && temp.id>=0) {
	    if (temp.y!=IDAGGIUNTAPID) {  //controlliamo se il messaggio proviene dal generatore dei coccodrilli
		coc_scelto=RanaSuCoccodrillo(&rana,coccodrilli);  //controllo di verifica che la rana sia gi√† su un coccodrillo (qualsiasi) prima dello spostamento
		coccodrilli[temp.id].x=temp.x;
		coccodrilli[temp.id].y=temp.y;
	        coccodrilli[temp.id].dir=temp.info;  
		
		//controlli per lo spostamento della rana
		if (coc_scelto==coccodrilli[temp.id].id) {  //controlliamo che il coccodrillo attuale sia anche quello su cui la rana era posata prima dello spostamento
		    if ((rana.x<=2 && coccodrilli[temp.id].dir==-1) || (rana.x>=77 && coccodrilli[temp.id].dir==1)) {  //controllo se la rana si trova agli estremi della mappa			
			if (RanaSuCoccodrillo(&rana,coccodrilli)!=coc_scelto) {	//se la rana non viene considerata pi√π sopra l'attuale coccodrillo allora √® caduta in acqua sul bordo della mappa 
			    game_struct->vite--;
			    game_struct->score-=10;
			    return;
			}	
		    } else {	 //altrimenti la rana si muove con il coccodrillo (ovvero non si trovava agli estremi della mappa)					
		        rana.x+=coccodrilli[temp.id].dir;
		    }               			
		}	
		
		//controllo sullo stato del coccodrillo
		if (coccodrilli[temp.id].x>=POS_SPAWN_COC_DESTRA || coccodrilli[temp.id].x<=POS_SPAWN_COC_SINISTRA) {	//verifichiamo se il coccodrillo √® all'interno della mappa
		    coccodrilli[temp.id].alive=0;  //coccodrillo fuori dalla mappa = non attivo
		} else {  
		    coccodrilli[temp.id].alive=1;  //coccoddrillo dentro alla mappa = attivo/vivo
		}
			
			
			
			
		//gestione dello stato di attesa 
		if ((coccodrilli[temp.id].x==LARGHEZZA_GIOCO+2 && coccodrilli[temp.id].dir==-1) || (coccodrilli[temp.id].x==-3 && coccodrilli[temp.id].dir==1)) {  //controlliamo che il coccodrillo corrente stia effettivamente a inizio tragitto			
		    for (int i=0;i<MAX_CROCODILES;i++) {
		        indice_flusso=(coccodrilli[i].y-16)/3;  //individuiamo indice del flusso del coccoddrillo corrente
					
			if (i!=coccodrilli[temp.id].id && coccodrilli[i].y==coccodrilli[temp.id].y && ((coccodrilli[temp.id].x+distanze_coc[indice_flusso]>coccodrilli[i].x-4 && coccodrilli[temp.id].dir==1)||(coccodrilli[temp.id].x-distanze_coc[indice_flusso]<coccodrilli[i].x+4 && coccodrilli[temp.id].dir==-1)) && coccodrilli[i].wait!=1){
						
			   coccodrilli[temp.id].wait=1;    //lo mettiamo in wait perch√® ci sono coccodrilli non in wait vicino a dove spawna
		
			   kill(array_pid[temp.id],SIGSTOP);  //lo fermiamo finch√® questa situazioni permane
			}
		    }
		}
		
		
		
				
			
		for (int i=0;i<MAX_CROCODILES;i++) {
		    if (coccodrilli[i].wait==1) {
			indice_flusso=(coccodrilli[i].y-16)/3;
		        	
			riattivare=1;
			for (int j=0;j<MAX_CROCODILES;j++) {
			    if(i!=j && coccodrilli[j].y==coccodrilli[i].y && ((coccodrilli[i].x+distanze_coc[indice_flusso]>coccodrilli[j].x-4 && coccodrilli[i].dir==1)||(coccodrilli[i].x-distanze_coc[indice_flusso]<coccodrilli[j].x+4 && coccodrilli[i].dir==-1)) && coccodrilli[j].wait!=1){
			        riattivare=0;			 
			    }		
			}
			if (riattivare) {	  
					  
			    distanze_coc[indice_flusso]=rand_funz(7,10);                    //modifico la distanza da rispettare cos√¨ da variare un p√≤ la posizione dei coccodrilli;						
					
			    coccodrilli[i].wait=-1;    //lo mettiamo in wait perch√® ci sono coccodrilli non in wait vicino a dove spawna
			    kill(array_pid[i],SIGCONT);	
			}
		    }
		}
	    } else {  //altrimenti aggiungiamo il pid del coccodrillo all'array dei pid
	        array_pid[temp.id]=temp.info; //salva l id del coccodrillo creato;	
	    }
	}
	
	


	//se l'id √® delle granate
	if (temp.id>=IDGRANATE && temp.id<=IDGRANATE+2) {
	    if (temp.id==IDGRANATE+2) {
	        if (granate[0].alive==0 && granate[1].alive==0) {  //devono essere entrambe morte;		
	            sparaGranata(rana.x,rana.y,vel_proiettile,array_pid,pipe1,pipe2);
	            granate[0].alive=1;
                    granate[1].alive=1;
          
                    
	            
	        }
	    } else {
	        granate[temp.id-IDGRANATE].x=temp.x;	
		granate[temp.id-IDGRANATE].y=temp.y;
		
			   
	    }	  
	}
	
	
	
	
	//se l'id √® del proiettile
	if (temp.id==IDPROIETTILE) {	
	    proiettile.x=temp.x;
	    proiettile.y=temp.y;
	}
	
	
	//controllo collisione proiettile-bordi
	
	if((proiettile.x<1 || proiettile.x>LARGHEZZA_GIOCO-2) && proiettile.alive==1){
	
		killProcess(array_pid[IDPROIETTILE]);
		array_pid[IDPROIETTILE]=0;
		proiettile.alive=0;
	}
	
	
	
	//controllo collisione granate/bordi
	for (int i=0; i<2;i++) {
	    if((granate[i].x<1 || granate[i].x>LARGHEZZA_GIOCO-2) && granate[i].alive==1 && granate[i].x!=-1) {
	    	
	    	granate[i].alive=0;
	    	granate[i].x=-1;  
	    	granata_morta=i;
	    	write(pipe2[1],&granata_morta, sizeof(int));  //scriviamo al processo granate quale delle due granate √® morta
	    	
	    }
	}
	
	
	
	
	
	
	
	
	//controllo collisione rana-proiettile
	if (CollisioneRanaProiettile(rana,proiettile)==1) {      
		game_struct->vite--;
		game_struct->score-=15;
		return;
	    }
	
	//controllo collisione granata-proiettile
	for (int i=0; i<2; i++) {
	    if (granate[i].x==proiettile.x && granate[i].y==proiettile.y && proiettile.alive==1 && granate[i].alive==1) {
		killProcess(array_pid[IDPROIETTILE]);  //killiamo il proiettile
		array_pid[IDPROIETTILE]=0;
		//impostiamo a morti il proiettile e la granata
		proiettile.alive=0;
		granate[i].alive=0;
		granata_morta=i;
		write(pipe2[1],&granata_morta, sizeof(int));  //avverte il processo granata che una delle granate √® morta
		game_struct->score+=5;
	    }
	}
	
	
	
	
	
	
	
	
	//controllo per killare il processo granate una volta morte
	if (granate[0].alive==0 && granate[1].alive==0 && array_pid[IDGRANATE]!=0) { 
	   
	    killProcess(array_pid[IDGRANATE]);	
	    array_pid[IDGRANATE]=0;
	}
	
	//gestione dello sparo del proiettile
	if (rana.y<40 && rana.x>=15 && proiettile.alive==0) {	//funzione che fa sparare proiettili;
	    gettimeofday(&end,NULL);
	    for (int i=0;i<MAX_CROCODILES;i++) {
		if (coccodrilli[i].alive==1 && coccodrilli[i].y==rana.y && ((coccodrilli[i].x+4<rana.x-1-5 && coccodrilli[i].dir==1) || (coccodrilli[i].x-4>rana.x+1+5 && coccodrilli[i].dir==-1))) {   //in pratica il coccodrillo deve essere vivo, nello stesso flusso della rana e essere dietro di lei nel flusso;(in questo caso ho messo la condizione che ci devono essere almeno 10 caratteri tra rana e coccodrillo;
				
				
		    if (end.tv_sec - start.tv_sec>=random) {
			if (rand_funz(1,1)==1) {
			    sparaProiettile(coccodrilli[i],vel_proiettile,array_pid,pipe1); //sarebbe da passargli solo quello in scrittura!!!
			    proiettile.alive=1;
			}
					
			gettimeofday(&end,NULL);		
			gettimeofday(&start,NULL);
			random=rand_funz(2,4);	          //cambio intervallo di tempo;
		    }				
		}
	    }
	}
			//in pratica il timer va a conteggiare il tempo anche quando siamo fuori dal fiume per√≤ a noi non ce ne frega nieteüòéÔ∏è(si forse si √® capito che ho scoperto come si mettono le emoji dal tasto destro);
	
	
	
	
	
	
	
	
	
	
	
	
    //funzioni di gestione grafica del gioco
    werase(game);
    windowGeneration(game,COLS,LINES,game_struct);
    drawCoccodrilli(game,coccodrilli);
    draw_granate(game,granate);
    draw_proiettile(game,proiettile);
    draw_frog(game,rana);
    //print score
    wattron(game, COLOR_PAIR(15));
    mvwprintw(game, 2, 2, "Punteggio: %d ",game_struct->score);
    wattroff(game, COLOR_PAIR(15));
    
    //print vite
    wattron(game, COLOR_PAIR(15));
    mvwprintw(game, 2, 50, "Vite:");
    mvwhline(game, 2,55, ' ', 21);
    for(int i=0; i<game_struct->vite;i++){
    	mvwprintw(game, 2, 55+i*2, "‚ù§Ô∏è  ");
       
    } 
	    	
    wattroff(game, COLOR_PAIR(15));
    
    
    
    
    //print tempo
    wattron(game, COLOR_PAIR(15));
    mvwhline(game, 46,2, ' ', 10);
    mvwprintw(game, 46, 2, "Tempo: %d ",game_struct->tempo);
    wattroff(game, COLOR_PAIR(15));

    print_tempo(game,game_struct,tempo); //barra del tempo

    
    wrefresh(game);
    }
}


//funzione che mostra la barra del tempo rimanente
void print_tempo(WINDOW* game,Game_struct* game_struct, int tempo){

    wattron(game, COLOR_PAIR(7));
    mvwhline(game,46,15, ' ', (int)(62*((float)game_struct->tempo/tempo)));
    wattroff(game, COLOR_PAIR(7));
	

}


//funzione che controlla se la rana si trova in mappa
int RanaInFinestra(Rana rana, Temp temp){

    if(rana.x+temp.x>78) return 0;
    if(rana.x+temp.x<2) return 0;
    if(rana.y+temp.y>43) return 0;
    if(rana.y+temp.y<7) return 0;
    return 1;

}

//funzione di controllo collisione rana-proiettile
int CollisioneRanaProiettile(Rana rana,Proiettile proiettile){

    if((rana.x+1==proiettile.x || rana.x-1==proiettile.x) && rana.y==proiettile.y && proiettile.alive) return 1;
    else return 0;   
}

//funzione di controllo se la rana √® su una tana
int RanaSuTana(Rana rana, Game_struct* game_struct){
	 
    for (int i=0;i<5;i++) {
        if (rana.x>=8+(15)*i && rana.x<8+(15)*i+5 && game_struct->tane[i]==0) {
   	    game_struct->tane[i]=1;
 	    return 1;
 	}
    }
    return 0;
}
	 	
	 	
	 		 

//funzione che svuota la pipe 
void svuota_pipe(int pipe_fd){
	
    int a;
    sblocca_fd(pipe_fd);
    while (read(pipe_fd,&a,sizeof(int))!= -1) {
	
    }
    blocca_fd(pipe_fd);
}




//funzione che verifica se la rana √® su un coccodrillo
int RanaSuCoccodrillo(Rana *rana, Coccodrillo *coccodrilli){
    for (int i = 0; i < MAX_CROCODILES; i++) {
        if (coccodrilli[i].alive) {
            if ((rana->y == coccodrilli[i].y) &&  (rana->x-1>= coccodrilli[i].x-4) && (rana->x+1 <= coccodrilli[i].x+4)) {
                return coccodrilli[i].id; 
            }
        }
    }
    return -1; 
}




//funzione di creazione dei processi
void creazione_processi(Flusso *flussi, int array_pid[N_PID], int pipe1[], WINDOW* game){
	
    for (int i=0;i<N_PID;i++) {
	array_pid[i]=0;  //settiamo tutti i pid a 0 per cominciare a creare i processi
    }	

    array_pid[IDRANA]=fork();  //creaiamo il processo rana
    if (array_pid[IDRANA]==-1) {
	perror("Erorre nella fork della rana : ");
	exit(1);
    } else if (array_pid[IDRANA]==0) {
	frog(game,pipe1); 

    } else {  
        array_pid[IDTIME]=fork();  //creiamo il processo del tempo
	if (array_pid[IDTIME]==-1) {
	    perror("Erorre nella fork della rana : ");
	    exit(1);
	} else if (array_pid[IDTIME]==0) {
	    tempo(pipe1);
	} else {
	    array_pid[MAX_CROCODILES]=fork();  //creiamo il processo che gestisce la creazione dei coccodrilli
	    if (array_pid[MAX_CROCODILES]==-1) {
		perror("Errore nella fork del generatore coccodrilli: ");
		exit(-1);
	    } else if (array_pid[MAX_CROCODILES]==0) {
	        funzione_gestione_coccodrilli(flussi,pipe1);
	        exit(-1);
	    } else return;
	}
    }
}

//funzione che assegna una velocit√† a ogni flusso
void def_vel_flussi(Flusso *flussi, int vel){
	
    
    int altezza_base=37;  //posizione del primo flusso (quello pi√π in basso)
    int dimensione_flussi=3;  //larghezza dei flussi
    for (int i=0;i<8;i++) {
        flussi[i].y=altezza_base - i*dimensione_flussi;
	flussi[i].speed= rand_funz(vel - 10000,vel+10000);
    }
}




//funzione che assegna una direzione ad ogni flusso
void def_dir_flussi(Flusso *flussi){
    for (int i=0;i<8;i++) {
	if (i>=1) {  //tutti i flussi dal secondo in poi hanno direzione opposta al flusso precedente
	    flussi[i].dir= -flussi[i-1].dir;

	} else {
	    //impostiamo la direzione del primo flusso in modo randomico
	    flussi[i].dir= rand()%2;
	    if (flussi[i].dir==0) flussi[i].dir=1;
	    else flussi[i].dir=-1;
	}
    }	
}

//funzione gestione proiettile
void funz_proiettile(Coccodrillo coccodrillo,int vel,int pipe1[]){   //vediamo per le pipe;
    close(pipe1[0]);
    Temp proiettile={IDPROIETTILE,0,0,0};
	
    //impostiamo il proiettile in base al coccodrillo che lo ha sparato
    if (coccodrillo.dir==1) proiettile.x=coccodrillo.x+5;
    else proiettile.x=coccodrillo.x-5;	
    proiettile.y=coccodrillo.y;	

    while (true) {
        
	
	    
        write(pipe1[1], &proiettile, sizeof(Temp));  			
        proiettile.x+=coccodrillo.dir;
        usleep(vel);
	
    }
}

//funzion di gestione dei coccodrilli
void funzione_gestione_coccodrilli(Flusso *flussi,int pipe1[]){
   
    int numero_coc_flussi[8]={0};
    int flusso_random;
    Temp coccodrillo;
    Temp messaggio;   
    pid_t pid_coc;
    
    for(int i=0;i<MAX_CROCODILES;i++){
    
        do {
            flusso_random=rand_funz(0,7);
           
        }while(numero_coc_flussi[flusso_random]==3);  //cerchiamo un flusso random che abbia meno di 3 coccodrilli;
   
   
   
   
       	
	//imposto il coccodrillo
	coccodrillo.id=i;
	coccodrillo.info=0;
	coccodrillo.y=flussi[flusso_random].y;
	numero_coc_flussi[flusso_random]++;
	
	if (flussi[flusso_random].dir==1) {
	    coccodrillo.x=POS_SPAWN_COC_SINISTRA-1;   
	} else {
	    coccodrillo.x=POS_SPAWN_COC_DESTRA+1;
	}
	
	pid_coc=fork();
	if (pid_coc==-1) {
	    perror("Errorre nella fork coccodrillo: ");
	    exit(1);
	} else if (pid_coc==0) {
		funzione_coccodrillo(coccodrillo,flussi,flusso_random,pipe1);
	} else {
	    
	    messaggio.info=pid_coc;						//imposto il messsaggio fa inviare
	    messaggio.id=i;
	    messaggio.y=IDAGGIUNTAPID;                            //serve per far capire che √® un nuovo pid da aggiungere nella lista dei pid;      
	
	    write(pipe1[1], &messaggio,sizeof(Temp));                          //invio messaggio alla principale con pid del coc creato       
	    usleep(rand_funz(500000,800000));}
	    if (i== MAX_CROCODILES/2) {
		usleep(rand_funz(2000000,3000000));				//a met√† della creazione dei coc fermo la loro generazione per qualche secondo;
	    }
    } 
}	
  
  

//funzione i controllo del coccodrillo
void funzione_coccodrillo(Temp coccodrillo,Flusso flussi[8],int id_flusso_scelto, int pipe1[]){
    close(pipe1[0]);
    usleep(rand_funz(100000,300000));
    Flusso flusso_scelto=flussi[id_flusso_scelto];  //serve per salvare il flusso scelto ad ogni spawn;
    coccodrillo.info=flusso_scelto.dir;
    
    
    while (true) {

	
	coccodrillo.x=coccodrillo.x+flusso_scelto.dir;
	write(pipe1[1], &coccodrillo, sizeof(Temp));  //invia la prima posizone quando il primo carattere del coccodrillo √® nello schermo;
	usleep(flusso_scelto.speed);
	
	
	//se il coccodrillo esce fuori dalla mappa allora deve cambiare flusso
	if ((coccodrillo.x>=POS_SPAWN_COC_DESTRA && flusso_scelto.dir==1) || (coccodrillo.x<=POS_SPAWN_COC_SINISTRA && flusso_scelto.dir==-1)) {  
	  
	
	    if (flusso_scelto.dir==1) {
	    
	        coccodrillo.x=POS_SPAWN_COC_SINISTRA;
	        
	    } else {
	    
	        coccodrillo.x=POS_SPAWN_COC_DESTRA;
	    }
	    usleep(rand_funz(1000000,2000000));}
	    	
    }
}



//funzione che gestisce il tempo
void tempo(int* pipe1){
    close(pipe1[0]);
    Temp tempo={0,0,0,0};		
    tempo.id=IDTIME;
    while(true) {
	sleep(1);
	write(pipe1[1], &tempo, sizeof(Temp)); //manda un messaggio alla funzione di controllo ogni secondo
    }

    _exit(0);
}
	

   
//funzione per killare un processo
void killProcess(pid_t pid){
    int status;
    if(kill(pid, SIGKILL)!=0) {
	perror("errore nel killare il processo: ");
	exit(-1);
    } else {
        waitpid(pid, &status, 0);
    }
}

//funzione per killare pi√π processi
void kill_processi(pid_t pid[N_PID]) {
	
    for (int i=0; i<N_PID;i++) {
	if(pid[i]>0) {
	    if(kill(pid[i],SIGKILL)!=0) {
		perror("Error killing process");
		exit(-1);
	    } else {
	        waitpid(pid[i], NULL, 0);
	        pid[i]=0;
	    }
	}			
    }
}
   	
 


int menu(WINDOW *game, const char *title, const char *options[], int num_options){
    flushinp();  // Elimina input residuo
    keypad(game, true);  // Abilita l'input da tastiera

    int position = 0;
    int gameLINES = getmaxy(game);
    int gameCOLS = getmaxx(game);

    while (true) {
        wclear(game);
        box(game, ACS_VLINE, ACS_HLINE);

        mvwprintw(game, gameLINES / 2 - 5, gameCOLS / 2 - strlen(title)/2, "%s", title);
        for (int i = 0; i < num_options; i++) {
            if (position == i) {
                wattron(game, COLOR_PAIR(9));
            }

            int x = gameCOLS / 2 - (strlen(options[i]) / 2);
            mvwprintw(game, gameLINES / 2 - 1 + i, x, "%s", options[i]);

            
            wattroff(game, COLOR_PAIR(9));
        }

        int choice = wgetch(game);
        switch (choice) {
            case KEY_DOWN:
                position++;
                if (position >= num_options) position = 0;
                break;
            case KEY_UP:
                position--;
                if (position < 0) position = num_options-1;
                break;
            case 10: // Invio
                return position;
        }

        wrefresh(game);
    }
}


//funzione che mostra i crediti
void credits(WINDOW *game){
    wclear(game);
    box(game, ACS_VLINE, ACS_HLINE);

    int gameLINES = getmaxy(game);
    int gameCOLS = getmaxx(game);

    mvwprintw(game, gameLINES / 2 - 2, gameCOLS / 2 - 15, "Marta Viglietti");
    mvwprintw(game, gameLINES / 2 - 1, gameCOLS / 2 - 15, "Gabriele Stampatori");
    mvwprintw(game, gameLINES / 2 + 1, gameCOLS / 2 - 17, "Premi un tasto per tornare al menu...");

    wrefresh(game); 
    wgetch(game);
}


//funzione utile per creare un numero random tra un minimo e un massimo (compresi)
int rand_funz(int min, int max){

    return min + rand() % (max-min+1);

}











void frog(WINDOW* game,int pipe1[2]){
    close(pipe1[0]);
    
    int key;
    Temp rana={IDRANA,0,0,0};  //messaggio usato per inviare alla funzione di controllo i movimenti della rana     
    Temp granata={IDGRANATE+2,0,0,0};  //messaggio con id apposito per la creazione delle granate
    keypad(game, true);
    

    while (true) {
    
        //Cattura l'input da tastiera
        key = (int)wgetch(game);
        rana.x=0;
        rana.y=0;

        switch (key) {
            case KEY_UP:  //movimento verso l'alto
                rana.y=-3;
                write(pipe1[1], &rana, sizeof(Temp));
                break;		
                	
            case KEY_DOWN:  //movimento verso il basso
                rana.y=3;
                write(pipe1[1], &rana, sizeof(Temp));
                break; 		
  
               
            case KEY_LEFT:  //movimento verso sinistra
                rana.x=-2;
                write(pipe1[1], &rana, sizeof(Temp));		
                break;
                
            case KEY_RIGHT:  //movimento verso destra
                rana.x=2;
                write(pipe1[1], &rana, sizeof(Temp));		
                break;
            case 's':  //tasto per sparare le granate 
            	
            	write(pipe1[1],&granata,sizeof(Temp));  //mandiamo messaggio alla funzione di controllo indicando che abbiamo l'intenzione di sparare le granate
                
                break;
         
        }  
    }
}


//funzione che gestisce la creazione del processo granata
void sparaGranata(int startX, int startY,int velocit√†_proiettile ,int pid_array[],int pipe1[], int pipe2[]){
    pid_array[IDGRANATE]= fork(); //Crea un nuovo processo per la granata

    if (pid_array[IDGRANATE] < 0) {
        perror("Errore nella creazione del processo granata");
        exit(0); 
    }

    if (pid_array[IDGRANATE] == 0) {  
        
        granata(startX, startY,velocit√†_proiettile, pipe1,pipe2);  //chiamiamo la funzione granata all'interno del processo figlio
    }
}


//funzione che gestisce la creazione del processo proiettile
void sparaProiettile(Coccodrillo coccodrillo,int velocit√†_proiettile, int pid_array[], int pipe1[]){
    pid_array[IDPROIETTILE]= fork(); // Crea un nuovo processo per la granata

    if (pid_array[IDPROIETTILE] < 0) {
        perror("Errore nella creazione del processo proiettile");
        exit(-1);
    }

    if (pid_array[IDPROIETTILE] == 0) {
   
        funz_proiettile(coccodrillo,velocit√†_proiettile,pipe1);  //chiamiamo la funzione proiettile all'interno del processo figlio
       
    }
}



//funzione che gestisce il processo granata
void granata(int startX, int startY, int velocit√†_proiettile, int pipe1[], int pipe2[]){		//posizione della rana;
    						//facciamo partire dal basso i proie#include <sys/time.h>ttili essendo la bocca della rana e del coccodrillo nella parte bassa;
    close(pipe2[1]);
    close(pipe1[0]);
    Temp granate[2];
    int messaggio;
    //variabili che gestiscono lo stato delle granate
    int alive_destra=1;
    int alive_sinistra=1;
   
    //impostazione iniziale delle granate (id e posizione di partenza)
    granate[0].id=IDGRANATE; 
    granate[1].id=IDGRANATE + 1;
    granate[0].x=startX - 2;
    granate[1].x=startX + 2; 			
    granate[0].y=startY;
    granate[1].y=startY;   
    granate[0].info=0;
    granate[1].info=0;
    
    int a;
    while (read(pipe2[0],&a,sizeof(int))!= -1) {
	
    }
    

    while (true) {
    	
    	
    	while(read(pipe2[0],&messaggio,sizeof(int))!=-1){  //leggiamo il messaggio nella pipe
            if (messaggio){
                
                alive_destra=0;
            } else { 
                alive_sinistra=0;
                	
            }
        }
        if (alive_destra) {
	    write(pipe1[1],&granate[1],sizeof(Temp));	 
	    granate[1].x++; 
	}
        	
        if (alive_sinistra) {
	    write(pipe1[1],&granate[0],sizeof(Temp));
	    granate[0].x--;
	}
        usleep(velocit√†_proiettile); // Velocit√† del movimento   
    }
 	       
        
}

//funzione che crea i colori utilizzati durante il gioco
void creazione_colori(){
    if (has_colors()) { //verifica il supporto ai colori da parte del terminale
        start_color();
        init_color(8,0,300,0);     //verde foresta
   	init_color(9,0,123,184);     //blu scuro		
  	init_color(10,95,95,95);     //grigio scuro
  	init_color(11,192,192,192);  //grigio chiaro
   	init_color(12,101,67,33);    //marrone
   	init_color(13,230,118,84);   //marrone pastello
   	init_color(14,50,300,50);    //verde chiaro
        init_color(15,0,500,0);      //verde chiaro
        init_color(16, 150,200,0);   //verde scuro
        init_color(17,100,500,700);  //blu chiaro
        
    	init_pair(1,8,14);                         //rana
   	init_pair(2, COLOR_BLUE, 17);	           //per i "~" del fiume
   	init_pair(3, COLOR_YELLOW, COLOR_YELLOW);  //zona in torno alle tane
   	init_pair(4, 10, 11);                      //recinzione delle tane
    	init_pair(5, 13, 13); 		           //tana vera e propria
   	init_pair(6, COLOR_YELLOW, 16);            //marciapiede
   	init_pair(7, COLOR_WHITE, COLOR_MAGENTA);  //punteggio e vite	
   	init_pair(8, 8, 15);   	                   //prato;
        init_pair(9,COLOR_BLACK,COLOR_WHITE);	   //selezione men√π
        init_pair(10,COLOR_BLACK,14);              //coccodrillo
        init_pair(11,COLOR_RED,COLOR_BLUE);	   //proiettile
        init_pair(12,COLOR_YELLOW,COLOR_GREEN);    //granata nel prato
        init_pair(13,COLOR_YELLOW,COLOR_BLUE);	   //granata fiume
        init_pair(14,COLOR_RED,COLOR_RED); 	   //zona esterna al gioco
        init_pair(15,COLOR_WHITE,14);		   //colore score-vite-tempo
                
    } else {  //il terminale non supporta i colori
    	printw("Il terminale non permette la visualizzazione dei colori\n"); 
    	mvprintw(LINES-1/2,COLS/2,"Premi un tasto per uscire...");refresh();
    	getch();
    	_exit(0);
    }
	
	
}




//funzione per disegnare il proiettile nella mappa
void draw_proiettile(WINDOW* game, Proiettile proiettile){
	
    if (proiettile.alive) {  //mostriamo il proiettile solo se vivo		
        wattron(game,COLOR_PAIR(11));
	
	    mvwaddch(game,proiettile.y,proiettile.x,'-');		
	
	wattroff(game,COLOR_PAIR(11));
	}		
}




void draw_granate(WINDOW* game, Granata granate[2]){
	
	
    for (int i=0;i<2;i++) {
	if (granate[i].alive) { //mostriamo le granate solo se vive
				
	    if (granate[i].y<15 && granate[i].y>=10) {  //granata sul marciapiede
		wattron(game,COLOR_PAIR(6));
		mvwaddch(game,granate[i].y,granate[i].x,'X');
		wattroff(game,COLOR_PAIR(6));			
	    }
	    if (granate[i].y<40 && granate[i].y>=15) {  //granata sul fiume
		wattron(game,COLOR_PAIR(11));
		mvwaddch(game,granate[i].y,granate[i].x,'X');
		wattroff(game,COLOR_PAIR(11));
	    }	
	    if (granate[i].y<45 && granate[i].y>=40) {  //granata sul prato
		wattron(game,COLOR_PAIR(12));
		mvwaddch(game,granate[i].y,granate[i].x,'X');
		wattroff(game,COLOR_PAIR(12));
            }
	}
    }
}

//funzione che disegna la rana
void draw_frog(WINDOW *game, Rana rana){
	
    
    wattron(game,COLOR_PAIR(1));
    
    for (int i = 0; i < ALTEZZARANA; i++) {
        for (int j = 0; j < LARGHEZZARANA; j++) {			
            mvwaddch(game, rana.y + i, rana.x -1 + j, frog_sprite[i][j]);
        }
    }
    wattroff(game,COLOR_PAIR(1));
}






//funzione che disegna i coccodrilli
void drawCoccodrilli(WINDOW *game, Coccodrillo *coccodrilli){
    int h;  //variabile utilizzata per tenere conto di quale parte del coccodrillo stiamo printando (inferiore o superiore)
    wattron(game, COLOR_PAIR(10));
    
    for (int i = 0; i < MAX_CROCODILES; i++) {
        if (coccodrilli[i].alive && coccodrilli[i].dir==1 && coccodrilli[i].wait!=1) { //coccodrillo vivo e direzionato verso destra
          
            h=0; 
	    
	    //printiamo la parte superiore del coccodrillo
            for (int j = 0; j < LARGHEZZACOCCODRILLO-2; j++) {
	        if (coccodrilli[i].x-3+j>0 && coccodrilli[i].x-3+j<LARGHEZZA_GIOCO-1) {  //condizioni necessarie per printare solo le parti del coccodrillo all'interno della mappa	
	       	    mvwaddch(game, coccodrilli[i].y + h, coccodrilli[i].x -3 + j, coc_sprite[0][h][j]);   
    	        }
   	    }
            h=1;
            
            //printiamo la parte inferiore del coccodrillo
            for (int j = 0; j < LARGHEZZACOCCODRILLO; j++) {
       	        if (coccodrilli[i].x-4+j>0 && coccodrilli[i].x-4+j<LARGHEZZA_GIOCO-1) {			
       		     	mvwaddch(game, coccodrilli[i].y + h, coccodrilli[i].x -4 + j, coc_sprite[0][h][j]);
     	    	}
   	    }
            
       
            
        } else if (coccodrilli[i].alive && coccodrilli[i].dir==-1 &&  coccodrilli[i].wait!=1) {   //coccodrillo vivo e direzionato verso sinistra
       	    
       	    h=0; 
            
            
            //printiamo la parte superiore del coccodrillo
            for (int j = 0; j < LARGHEZZACOCCODRILLO-2; j++) {
	        if (coccodrilli[i].x-3+j>0 && coccodrilli[i].x-3+j<LARGHEZZA_GIOCO-1) {			
	     	    mvwaddch(game, coccodrilli[i].y + h, coccodrilli[i].x -3 + j, coc_sprite[1][h][j]);   //prima riga , colonna h, al carattere n j;
    		}
   	    }
            h=1;
            
            //printiamo la parte inferiore del coccodrillo
            for (int j = 0; j < LARGHEZZACOCCODRILLO; j++) {
       		   if (coccodrilli[i].x-4+j>0 && coccodrilli[i].x-4+j<LARGHEZZA_GIOCO-1) {			
       		     	mvwaddch(game, coccodrilli[i].y + h, coccodrilli[i].x -4 + j, coc_sprite[1][h][j]);
     	    	   }
   	    }  
        }
    }
    wattroff(game, COLOR_PAIR(10));
}



//funzione che sblocca le pipe
void sblocca_fd(int fd) {

    int flags = fcntl(fd, F_GETFL);
    if (flags == -1) {
        perror("Errore nell'ottenere i flag del fd");
        exit(-1);
    }
    if (fcntl(fd, F_SETFL, flags | O_NONBLOCK) == -1) {
        perror("Errore nel settare O_NONBLOCK");
        exit(-1);
    }
}


//funzione che blocca le pipe
void blocca_fd(int fd) {

    int flags = fcntl(fd, F_GETFL);
    if (flags == -1) {
        perror("Errore nell'ottenere i flag del fd");
        exit(-1);
    }
    flags &= ~O_NONBLOCK;
    if (fcntl(fd, F_SETFL, flags) == -1) {
        perror("Errore nel rimuovere O_NONBLOCK");
        exit(-1);
    }
}
